<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux设置Systemctl服务</title>
      <link href="/2025/09/02/Linux%E8%AE%BE%E7%BD%AESystemctl%E6%9C%8D%E5%8A%A1/"/>
      <url>/2025/09/02/Linux%E8%AE%BE%E7%BD%AESystemctl%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是Systemctl"><a href="#一、什么是Systemctl" class="headerlink" title="一、什么是Systemctl"></a>一、什么是Systemctl</h2><h3 id="1-1-Systemctl简介"><a href="#1-1-Systemctl简介" class="headerlink" title="1.1 Systemctl简介"></a>1.1 Systemctl简介</h3><p><code>Systemctl</code>是Linux系统中用于管理<code>systemd</code>系统和服务管理器的主要命令行工具。它允许用户查看、启动、停止、重启、启用和禁用系统服务，以及检查服务状态等。</p><h3 id="1-2-Systemd与Systemctl的关系"><a href="#1-2-Systemd与Systemctl的关系" class="headerlink" title="1.2 Systemd与Systemctl的关系"></a>1.2 Systemd与Systemctl的关系</h3><p><code>Systemd</code>是Linux系统的初始化系统和服务管理器，负责启动系统、管理后台进程和服务。</p><p>而<code>Systemctl</code>则是与<code>systemd</code>交互的命令行接口工具，用户通过<code>Systemctl</code>命令来控制和管理<code>systemd</code>服务。</p><p>简单来说，<code>systemd</code>是底层的服务管理系统，<code>Systemctl</code>是用户操作这个系统的工具。</p><h3 id="1-3-为什么需要使用Systemctl管理服务"><a href="#1-3-为什么需要使用Systemctl管理服务" class="headerlink" title="1.3 为什么需要使用Systemctl管理服务"></a>1.3 为什么需要使用Systemctl管理服务</h3><ul><li><strong>统一管理</strong>：<code>Systemctl</code>提供了统一的接口来管理各种系统服务，取代了传统的SysV init脚本。</li><li><strong>服务依赖</strong>：<code>Systemctl</code>可以轻松处理服务之间的依赖关系，确保服务按正确顺序启动。</li><li><strong>状态监控</strong>：实时查看服务运行状态，快速定位问题。</li><li><strong>开机自启</strong>：便捷设置服务开机自启动或禁用自启动。</li><li><strong>资源管理</strong>：通过cgroups对服务进行资源限制和管理。</li><li><strong>日志管理</strong>：<code>Systemctl</code>可以查看服务的日志，帮助定位问题。</li></ul><p>对于日常工作而言，掌握<code>Systemctl</code>可以帮助我们更高效地管理和维护Linux系统服务，确保服务稳定运行。</p><h2 id="二、服务文件基础"><a href="#二、服务文件基础" class="headerlink" title="二、服务文件基础"></a>二、服务文件基础</h2><h3 id="2-1-服务文件的位置与命名规则"><a href="#2-1-服务文件的位置与命名规则" class="headerlink" title="2.1 服务文件的位置与命名规则"></a>2.1 服务文件的位置与命名规则</h3><p><code>Systemd</code>服务文件主要存放在两个目录：</p><ul><li><strong>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;</strong>：<strong>用户自定义服务</strong>文件通常放在这个目录</li><li><strong>&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</strong>：<strong>系统自带服务</strong>文件存放在这里</li></ul><p>服务文件的命名必须以<code>.service</code>为后缀，例如<code>myapp.service</code>。文件名应简洁明了，能反映服务的功能。</p><blockquote><p>在启动服务时，输入的服务名称为文件名去掉后缀的部分，例如<code>myapp.service</code>的服务名称为<code>myapp</code>。当然也可以加上<code>.service</code>。</p></blockquote><h3 id="2-2-服务文件的基本结构"><a href="#2-2-服务文件的基本结构" class="headerlink" title="2.2 服务文件的基本结构"></a>2.2 服务文件的基本结构</h3><blockquote><p>这一块内容读者可以随机打开一个服务文件，查看其内容，对着下述的基本结构说明来辅助理解，同时尝试自己来添加服务。一般都会包含<code>[Unit]</code>、<code>[Service]</code>、<code>[install]</code>三部分。</p></blockquote><p>一个标准的Systemd服务文件由三个主要部分组成：</p><ul><li><code>[Unit]</code>：包含服务的描述、依赖关系等<strong>元数据</strong></li><li><code>[Service]</code>：定义服务的运行方式、启动命令等<strong>核心配置</strong></li><li><code>[Install]</code>：指定服务<strong>安装信息</strong>，如开机自启设置</li></ul><h3 id="2-3-核心配置项解释"><a href="#2-3-核心配置项解释" class="headerlink" title="2.3 核心配置项解释"></a>2.3 核心配置项解释</h3><h4 id="2-3-1-Unit-部分"><a href="#2-3-1-Unit-部分" class="headerlink" title="2.3.1 [Unit]部分"></a>2.3.1 [Unit]部分</h4><ul><li><code>Description</code>：服务的简短描述</li><li><code>Documentation</code>：服务文档的URL</li><li><code>After</code>：指定服务应在哪些服务之后启动</li><li><code>Requires</code>：指定服务依赖的其他服务，若依赖服务启动失败，当前服务也不会启动</li><li><code>Wants</code>：指定服务希望依赖的其他服务，若依赖服务启动失败，当前服务仍会尝试启动</li></ul><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Python Application</span><br><span class="line"><span class="attr">Documentation</span>=https://example.com/docs</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"><span class="attr">Requires</span>=mysql.service</span><br><span class="line"><span class="attr">Wants</span>=redis.service</span><br></pre></td></tr></table></figure><h4 id="2-3-2-Service-部分"><a href="#2-3-2-Service-部分" class="headerlink" title="2.3.2 [Service]部分"></a>2.3.2 [Service]部分</h4><ul><li><code>Type</code>：服务的类型，常见值：<ul><li><code>simple</code>（默认）：服务启动后立即进入后台运行</li><li><code>forking</code>：服务启动后会创建子进程，父进程退出</li><li><code>oneshot</code>：服务一次性运行完成后退出</li></ul></li><li><code>ExecStart</code>：启动服务的命令</li><li><code>ExecStop</code>：停止服务的命令</li><li><code>Restart</code>：指定服务何时应自动重启（如<code>always</code>、<code>on-failure</code>等）</li><li><code>User</code>：指定运行服务的用户</li><li><code>WorkingDirectory</code>：服务的工作目录</li><li><code>Environment</code>：设置环境变量</li></ul><blockquote><p>这里的关键点就是<code>ExecStart</code>和<code>ExecStop</code>这两个参数。决定了你实际服务的启动和停止。</p><p>例如，你可以使用<code>ExecStart=/usr/bin/python3 /path/to/myapp.py</code>来启动一个Python应用，使用<code>ExecStop=/bin/kill -TERM $MAINPID</code>来停止它。</p><p>其中，<code>$MAINPID</code>是一个环境变量，它会被<code>systemd</code>替换为服务的主进程ID。</p></blockquote><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/python3 /path/to/myapp.py</span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill -TERM <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">User</span>=www-data</span><br><span class="line"><span class="attr">WorkingDirectory</span>=/path/to/</span><br><span class="line"><span class="attr">Environment</span>=PYTHONPATH=/path/to/lib</span><br></pre></td></tr></table></figure><h4 id="2-3-3-Install-部分"><a href="#2-3-3-Install-部分" class="headerlink" title="2.3.3 [Install]部分"></a>2.3.3 [Install]部分</h4><ul><li><code>WantedBy</code>：指定服务被启用时应链接到哪个target（通常是<code>multi-user.target</code>）</li><li><code>Alias</code>：服务的别名</li></ul><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"><span class="attr">Alias</span>=myapp</span><br></pre></td></tr></table></figure><p>理解这些配置项是创建和管理Systemd服务的基础。在实际使用中，我们可以根据服务的特性调整这些配置。</p><h2 id="三、创建简单服务示例"><a href="#三、创建简单服务示例" class="headerlink" title="三、创建简单服务示例"></a>三、创建简单服务示例</h2><h3 id="3-1-示例场景介绍"><a href="#3-1-示例场景介绍" class="headerlink" title="3.1 示例场景介绍"></a>3.1 示例场景介绍</h3><p>假设我们有一个简单的Python脚本，它实现了一个基础的Web服务器，用于提供静态文件服务。我们希望将这个脚本作为系统服务运行，以便在系统启动时自动启动，并能通过Systemctl进行管理。</p><p>示例Python脚本（<code>simple_server.py</code>）内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> http.server</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义端口</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建请求处理器</span></span><br><span class="line">Handler = http.server.SimpleHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TCP服务器</span></span><br><span class="line"><span class="keyword">with</span> socketserver.TCPServer((<span class="string">&quot;&quot;</span>, PORT), Handler) <span class="keyword">as</span> httpd:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;服务启动在端口 <span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 启动服务器</span></span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure><h3 id="3-2-编写服务文件"><a href="#3-2-编写服务文件" class="headerlink" title="3.2 编写服务文件"></a>3.2 编写服务文件</h3><p>我们将创建一个名为<code>simple-server.service</code>的服务文件，存放在<code>/etc/systemd/system/</code>目录下。</p><p>完整服务文件内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Simple Python Web Server</span><br><span class="line"><span class="attr">Documentation</span>=https://example.com/docs</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/python3 /path/to/simple_server.py</span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill -TERM <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">User</span>=www-data</span><br><span class="line"><span class="attr">WorkingDirectory</span>=/path/to/webroot</span><br><span class="line"><span class="attr">Environment</span>=PYTHONUNBUFFERED=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"><span class="attr">Alias</span>=simple-server</span><br></pre></td></tr></table></figure><h3 id="3-3-服务文件各参数详解"><a href="#3-3-服务文件各参数详解" class="headerlink" title="3.3 服务文件各参数详解"></a>3.3 服务文件各参数详解</h3><h4 id="3-3-1-Unit-部分"><a href="#3-3-1-Unit-部分" class="headerlink" title="3.3.1 [Unit]部分"></a>3.3.1 [Unit]部分</h4><ul><li><code>Description</code>：服务的简短描述，这里描述为”Simple Python Web Server”</li><li><code>Documentation</code>：服务文档的URL，可以指向项目文档或说明</li><li><code>After=network.target</code>：指定服务应在网络服务启动后启动，确保网络可用</li></ul><h4 id="3-3-2-Service-部分"><a href="#3-3-2-Service-部分" class="headerlink" title="3.3.2 [Service]部分"></a>3.3.2 [Service]部分</h4><ul><li><code>Type=simple</code>：服务类型为simple，表示服务启动后立即进入后台运行</li><li><code>ExecStart=/usr/bin/python3 /path/to/simple_server.py</code>：启动服务的命令，指定Python解释器和脚本路径</li><li><code>ExecStop=/bin/kill -TERM $MAINPID</code>：停止服务的命令，使用kill命令发送TERM信号给主进程</li><li><code>Restart=on-failure</code>：指定服务在失败时自动重启</li><li><code>User=www-data</code>：指定运行服务的用户为www-data（Web服务器常用用户）</li><li><code>WorkingDirectory=/path/to/webroot</code>：服务的工作目录，这里设置为Web根目录</li><li><code>Environment=PYTHONUNBUFFERED=1</code>：设置环境变量，确保Python输出不缓冲</li></ul><h4 id="3-3-3-Install-部分"><a href="#3-3-3-Install-部分" class="headerlink" title="3.3.3 [Install]部分"></a>3.3.3 [Install]部分</h4><ul><li><code>WantedBy=multi-user.target</code>：指定服务被启用时链接到multi-user.target，这是默认的运行级别</li><li><code>Alias=simple-server</code>：服务的别名，方便用户通过别名管理服务</li></ul><h4 id="3-3-4-服务文件部署步骤"><a href="#3-3-4-服务文件部署步骤" class="headerlink" title="3.3.4 服务文件部署步骤"></a>3.3.4 服务文件部署步骤</h4><ol><li>将Python脚本放置在指定目录，例如<code>/opt/scripts/simple_server.py</code></li><li>赋予脚本执行权限：<code>chmod +x /opt/scripts/simple_server.py</code></li><li>创建服务文件：<code>sudo nano /etc/systemd/system/simple-server.service</code>，并粘贴上面的服务文件内容</li><li>重新加载Systemd配置：<code>sudo systemctl daemon-reload</code></li><li>启用服务：<code>sudo systemctl enable simple-server</code></li><li>启动服务：<code>sudo systemctl start simple-server</code></li></ol><p>通过以上步骤，我们就成功创建并启动了一个简单的Python Web服务器服务。</p><h2 id="四、服务管理命令"><a href="#四、服务管理命令" class="headerlink" title="四、服务管理命令"></a>四、服务管理命令</h2><p>Systemctl提供了一系列命令来管理服务，下面介绍最常用的几个命令：</p><h3 id="4-1-启用服务"><a href="#4-1-启用服务" class="headerlink" title="4.1 启用服务"></a>4.1 启用服务</h3><p>启用服务是指设置服务在系统开机时自动启动。启用服务后，即使系统重启，服务也会自动运行。</p><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> [服务名称]</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> simple-server</span><br></pre></td></tr></table></figure><h3 id="4-2-启动-停止服务"><a href="#4-2-启动-停止服务" class="headerlink" title="4.2 启动&#x2F;停止服务"></a>4.2 启动&#x2F;停止服务</h3><p>启动服务用于手动启动一个服务，停止服务用于手动停止一个正在运行的服务。</p><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start [服务名称]  <span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop [服务名称]   <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start simple-server  <span class="comment"># 启动我们创建的Python Web服务器服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop simple-server   <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure><h3 id="4-3-重启服务"><a href="#4-3-重启服务" class="headerlink" title="4.3 重启服务"></a>4.3 重启服务</h3><p>当服务配置发生变化或服务出现异常时，可以使用重启命令重新启动服务。</p><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart [服务名称]</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart simple-server</span><br></pre></td></tr></table></figure><h3 id="4-4-查看服务状态"><a href="#4-4-查看服务状态" class="headerlink" title="4.4 查看服务状态"></a>4.4 查看服务状态</h3><p>查看服务状态可以了解服务是否正在运行、是否启动成功、以及服务的详细信息。</p><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status [服务名称]</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status simple-server</span><br></pre></td></tr></table></figure><p><strong>输出说明</strong>：</p><ul><li><code>active (running)</code>：服务正在运行</li><li><code>inactive (dead)</code>：服务未运行</li><li><code>failed</code>：服务启动失败</li><li>输出中还包含服务的启动时间、主进程ID、以及最近的日志信息</li></ul><h3 id="4-5-查看服务日志"><a href="#4-5-查看服务日志" class="headerlink" title="4.5 查看服务日志"></a>4.5 查看服务日志</h3><p>查看服务日志可以帮助我们排查服务启动或运行过程中遇到的问题。</p><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u [服务名称]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-f</code>：实时跟踪日志输出</li><li><code>-n [数字]</code>：显示最近的[数字]行日志</li><li><code>--since &quot;YYYY-MM-DD HH:MM:SS&quot;</code>：显示指定时间之后的日志</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u simple-server  <span class="comment"># 查看服务的所有日志</span></span><br><span class="line"><span class="built_in">sudo</span> journalctl -u simple-server -f  <span class="comment"># 实时跟踪服务日志</span></span><br><span class="line"><span class="built_in">sudo</span> journalctl -u simple-server -n 50  <span class="comment"># 查看最近50行日志</span></span><br><span class="line"><span class="built_in">sudo</span> journalctl -u simple-server --since <span class="string">&quot;2023-10-01 00:00:00&quot;</span>  <span class="comment"># 查看10月1日之后的日志</span></span><br></pre></td></tr></table></figure><h3 id="4-6-禁用服务"><a href="#4-6-禁用服务" class="headerlink" title="4.6 禁用服务"></a>4.6 禁用服务</h3><p>禁用服务是指取消服务的开机自启动设置，但不会影响当前正在运行的服务。</p><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> [服务名称]</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> simple-server</span><br></pre></td></tr></table></figure><h3 id="4-7-其他常用命令"><a href="#4-7-其他常用命令" class="headerlink" title="4.7 其他常用命令"></a>4.7 其他常用命令</h3><ul><li><p><strong>重新加载服务配置</strong>：当修改了服务文件后，需要重新加载Systemd配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p><strong>查看服务是否启用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled [服务名称]</span><br></pre></td></tr></table></figure></li><li><p><strong>列出所有服务</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure></li></ul><p>通过以上命令，我们可以全面地管理和监控Systemd服务。在日常工作中，这些命令是使用Systemctl管理服务的基础。</p><h2 id="五、常见问题与解决"><a href="#五、常见问题与解决" class="headerlink" title="五、常见问题与解决"></a>五、常见问题与解决</h2><p>在使用Systemctl管理服务的过程中，可能会遇到各种问题。以下是一些常见问题及解决方法。</p><h3 id="服务启动失败的排查方法"><a href="#服务启动失败的排查方法" class="headerlink" title="服务启动失败的排查方法"></a>服务启动失败的排查方法</h3><p>当服务启动失败时，可以按照以下步骤进行排查：</p><ol><li><p><strong>查看服务状态</strong>：首先使用<code>systemctl status [服务名]</code>命令查看服务的当前状态和错误信息。这通常会显示服务启动失败的直接原因。</p></li><li><p><strong>检查配置文件语法</strong>：使用<code>systemctl daemon-reload</code>命令重新加载配置文件，如果配置文件有语法错误，会在此步骤报错。</p></li><li><p><strong>查看详细日志</strong>：通过<code>journalctl -u [服务名]</code>命令查看服务的详细日志，寻找错误提示。</p></li><li><p><strong>测试执行命令</strong>：如果服务是执行某个脚本或程序，可以尝试直接在命令行执行该命令，看是否能正常运行。</p></li><li><p><strong>检查依赖服务</strong>：使用<code>systemctl list-dependencies [服务名]</code>查看服务的依赖关系，确保所有依赖服务都已正常启动。</p></li></ol><h3 id="权限问题处理"><a href="#权限问题处理" class="headerlink" title="权限问题处理"></a>权限问题处理</h3><p>权限问题是服务启动失败的常见原因之一：</p><ol><li><p><strong>文件权限</strong>：确保服务文件和相关脚本具有正确的权限。通常服务文件应具有<code>644</code>权限，可执行脚本应具有<code>755</code>权限。</p></li><li><p><strong>用户权限</strong>：服务中指定的运行用户（通过<code>User=</code>和<code>Group=</code>配置）应具有访问相关文件和目录的权限。</p></li><li><p><strong>SELinux&#x2F;AppArmor限制</strong>：如果系统启用了SELinux或AppArmor，可能会限制服务的某些操作。可以通过查看相关日志或临时禁用这些安全机制来确认是否是权限问题。</p></li><li><p><strong>文件上下文</strong>：对于SELinux，确保文件具有正确的安全上下文。可以使用<code>chcon</code>或<code>restorecon</code>命令修复文件上下文。</p></li></ol><h3 id="路径问题解决"><a href="#路径问题解决" class="headerlink" title="路径问题解决"></a>路径问题解决</h3><p>路径问题也是常见的服务启动障碍：</p><ol><li><p><strong>使用绝对路径</strong>：在服务文件中，特别是<code>ExecStart=</code>、<code>ExecStop=</code>等指令中，应使用程序和文件的绝对路径，避免依赖环境变量。</p></li><li><p><strong>检查工作目录</strong>：如果服务需要在特定目录下运行，可以通过<code>WorkingDirectory=</code>配置指定工作目录。</p></li><li><p><strong>环境变量</strong>：如果程序依赖特定的环境变量，可以在服务文件中通过<code>Environment=</code>或<code>EnvironmentFile=</code>配置设置环境变量。</p></li><li><p><strong>路径不存在</strong>：确保服务文件中引用的所有路径（包括程序路径、配置文件路径、日志文件路径等）都存在。</p></li></ol><h3 id="日志查看技巧"><a href="#日志查看技巧" class="headerlink" title="日志查看技巧"></a>日志查看技巧</h3><p>有效查看日志对于排查问题至关重要：</p><ol><li><p><strong>实时查看日志</strong>：使用<code>journalctl -u [服务名] -f</code>命令实时查看服务的日志输出。</p></li><li><p><strong>查看特定时间范围的日志</strong>：使用<code>journalctl -u [服务名] --since &quot;2025-07-01 10:00:00&quot; --until &quot;2025-07-01 11:00:00&quot;</code>查看特定时间段的日志。</p></li><li><p><strong>过滤错误日志</strong>：使用<code>journalctl -u [服务名] -p err</code>只查看错误级别的日志。</p></li><li><p><strong>查看引导以来的日志</strong>：使用<code>journalctl -u [服务名] -b</code>查看当前引导以来的服务日志。</p></li><li><p><strong>导出日志</strong>：如果需要保存日志供后续分析，可以使用<code>journalctl -u [服务名] --output=short-precise &gt; service.log</code>将日志导出到文件。</p></li></ol><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>从基础概念出发，我们理解了Systemctl作为管理Systemd的命令行工具的重要性，以及其统一管理、服务依赖等五大核心优势。在服务文件学习中，我们详细了解了服务文件的两个主要存放位置（&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;和&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;）、.service后缀命名规则，以及[Unit]、[Service]、[Install]三个核心部分的配置项含义与用法。</p><p>通过Python Web服务器的实例，我们亲身体验了创建服务文件、部署和管理服务的完整流程，掌握了从编写脚本到启用、启动服务的全步骤操作。在命令管理部分，我们系统学习了启用（enable）、启动&#x2F;停止（start&#x2F;stop）、重启（restart）、查看状态（status）、查看日志（journalctl -u）、禁用（disable）等常用命令，以及daemon-reload等实用操作。</p><p>最后，针对常见问题，我们总结了服务启动失败排查的五步流程、权限问题处理技巧、路径问题解决方法和日志查看的多种实用技巧，为实际应用中可能遇到的问题提供了有效的解决方案。</p><p>本文内容通俗易懂，示例丰富，符合科普性质，无论是Linux初学者还是系统管理员，都能通过本文快速掌握Systemctl服务管理的核心技能，提升Linux系统管理效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pydantic使用指南</title>
      <link href="/2025/09/02/Pydantic%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2025/09/02/Pydantic%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><blockquote><p>以下Pydantic使用的版本为2.0.0，不同版本的Pydantic可能会有一些差异，特别是在一些新的功能和废弃的功能上，建议查看官方文档。</p></blockquote><h3 id="1-1-什么是Pydantic"><a href="#1-1-什么是Pydantic" class="headerlink" title="1.1 什么是Pydantic"></a>1.1 什么是Pydantic</h3><p>Pydantic是Python中最广泛使用的基于Python类型提示的数据验证和设置管理库，它遵循纯正的Python 3.9+标准，能帮助开发者轻松验证数据、管理配置并减少样板代码。该库快速且可扩展，能与代码分析器、集成开发环境良好配合，便于进行数据验证工作。</p><h3 id="1-2-为什么选择Pydantic"><a href="#1-2-为什么选择Pydantic" class="headerlink" title="1.2 为什么选择Pydantic"></a>1.2 为什么选择Pydantic</h3><ul><li><strong>由类型提示驱动</strong>：用Pydantic的时候，模式验证和序列化都靠类型注解来控制。就不用学太多东西，也不用写很多代码，还能和IDE以及静态分析工具完美配合。</li><li><strong>速度快</strong>：Pydantic的核心验证逻辑是用Rust写的，所以它是Python里最快的数据验证库之一。</li><li><strong>支持JSON Schema</strong>：Pydantic模型能生成JSON Schema，这样就能轻松和其他工具集成。</li><li><strong>严格模式和宽松模式</strong>：Pydantic有两种模式可以选。严格模式下，数据不会被转换；宽松模式下，Pydantic会在合适的时候把数据转换成正确的类型。</li><li><strong>支持多种标准库类型</strong>：Pydantic能验证很多标准库的类型，像数据类、类型字典这些都不在话下。</li><li><strong>可自定义</strong>：Pydantic允许自定义验证器和序列化器，用各种方式来改变数据处理的方法。</li><li><strong>生态系统强大</strong>：PyPI上大概有8000个包都在用Pydantic，像FastAPI、huggingface、Django Ninja、SQLModel和LangChain这些流行的库也都在用。</li><li><strong>经过实战检验</strong>：Pydantic每个月的下载量超过3.6亿次，FAANG所有公司，还有纳斯达克25家最大企业里的20家都在用它。</li></ul><blockquote><p>以上内容是摘自官网的，不过也确实很好用，在项目中用的比较多😄，特别是用Fast API做后端的时候，会帮你规范接收的JSON数据，多了一个校验层，减少了很多的错误。</p></blockquote><h3 id="1-3-应用场景"><a href="#1-3-应用场景" class="headerlink" title="1.3 应用场景"></a>1.3 应用场景</h3><ul><li><strong>API请求和响应验证</strong>：这个也是我实际工作中用的比较多的，用Fast API作为后端接收数据时，会使用Pydantic来验证客户端发送的请求数据和服务器返回的响应数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建FastAPI应用实例</span></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Pydantic模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    is_offer: <span class="built_in">bool</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建路由，使用Pydantic模型进行请求体验证</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_item</span>(<span class="params">item: Item</span>):</span><br><span class="line">    <span class="comment"># 这里可以处理item，例如保存到数据库</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_name&quot;</span>: item.name, <span class="string">&quot;item_price&quot;</span>: item.price, <span class="string">&quot;is_offer&quot;</span>: item.is_offer&#125;</span><br></pre></td></tr></table></figure><p>这个示例中的流程如下：</p><ol><li>导入FastAPI和BaseModel</li><li>创建FastAPI应用实例</li><li>定义与之前相同的Item模型</li><li>创建POST路由，使用Item模型验证请求体</li><li>在路由处理函数中，直接使用验证后的item数据</li></ol><blockquote><p>当客户端发送POST请求到<code>/items/</code>端点时，FastAPI获取的数据会先通过Pydantic模型进行验证，如果不符合会返回详细的错误信息，这里的错误信息是Pydantic提供的，不是FastAPI提供的，Fast API作为后端获取客户端发来的数据。这也侧面说明Pydantic可以在很多场景下使用，不仅限于Fast API。</p></blockquote><ul><li><strong>配置管理</strong>：管理应用程序的配置，确保配置数据的正确性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="keyword">from</span> pydantic_settings <span class="keyword">import</span> SettingsConfigDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="comment"># 应用基本信息</span></span><br><span class="line">    app_name: <span class="built_in">str</span> = <span class="string">&quot;Awesome API&quot;</span></span><br><span class="line">    app_version: <span class="built_in">str</span> = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    debug: <span class="built_in">bool</span> = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 管理员信息</span></span><br><span class="line">    admin_email: <span class="built_in">str</span></span><br><span class="line">    admin_phone: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据库配置</span></span><br><span class="line">    db_host: <span class="built_in">str</span> = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    db_port: <span class="built_in">int</span> = <span class="number">5432</span></span><br><span class="line">    db_username: <span class="built_in">str</span> = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">    db_password: <span class="built_in">str</span> = Field(..., description=<span class="string">&quot;数据库密码，不应硬编码&quot;</span>)</span><br><span class="line">    db_name: <span class="built_in">str</span> = <span class="string">&quot;myapp&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># API配置</span></span><br><span class="line">    items_per_user: <span class="built_in">int</span> = <span class="number">50</span></span><br><span class="line">    api_key: <span class="built_in">str</span> = Field(..., description=<span class="string">&quot;API密钥，不应硬编码&quot;</span>)</span><br><span class="line">    jwt_secret: <span class="built_in">str</span> = Field(..., description=<span class="string">&quot;JWT密钥，不应硬编码&quot;</span>)</span><br><span class="line">    jwt_expiry_minutes: <span class="built_in">int</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pydantic v2 配置方式</span></span><br><span class="line">    model_config = SettingsConfigDict(</span><br><span class="line">        env_file=<span class="string">&quot;.env&quot;</span>,  <span class="comment"># 从.env文件加载环境变量</span></span><br><span class="line">        case_sensitive=<span class="literal">True</span>,  <span class="comment"># 区分大小写</span></span><br><span class="line">        env_prefix=<span class="string">&quot;APP_&quot;</span>,  <span class="comment"># 环境变量前缀</span></span><br><span class="line">        extra=<span class="string">&quot;forbid&quot;</span>  <span class="comment"># 禁止未知字段</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置实例</span></span><br><span class="line"><span class="comment"># 注意：敏感信息如密码、密钥等不应硬编码</span></span><br><span class="line"><span class="comment"># 应该通过环境变量或.env文件提供</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    settings = Settings()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;应用名称: <span class="subst">&#123;settings.app_name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;数据库连接: postgresql://<span class="subst">&#123;settings.db_username&#125;</span>:*****@<span class="subst">&#123;settings.db_host&#125;</span>:<span class="subst">&#123;settings.db_port&#125;</span>/<span class="subst">&#123;settings.db_name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;配置加载失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">配置加载失败: 4 validation errors for Settings</span></span><br><span class="line"><span class="string">admin_email</span></span><br><span class="line"><span class="string">  Field required [type=missing, input_value=&#123;&#125;, input_type=dict]</span></span><br><span class="line"><span class="string">    For further information visit https://errors.pydantic.dev/2.11/v/missing</span></span><br><span class="line"><span class="string">db_password</span></span><br><span class="line"><span class="string">  Field required [type=missing, input_value=&#123;&#125;, input_type=dict]</span></span><br><span class="line"><span class="string">    For further information visit https://errors.pydantic.dev/2.11/v/missing</span></span><br><span class="line"><span class="string">api_key</span></span><br><span class="line"><span class="string">  Field required [type=missing, input_value=&#123;&#125;, input_type=dict]</span></span><br><span class="line"><span class="string">    For further information visit https://errors.pydantic.dev/2.11/v/missing</span></span><br><span class="line"><span class="string">jwt_secret</span></span><br><span class="line"><span class="string">  Field required [type=missing, input_value=&#123;&#125;, input_type=dict]</span></span><br><span class="line"><span class="string">    For further information visit https://errors.pydantic.dev/2.11/v/missing</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>不难发现，Pydantic的配置管理功能非常强大，能够帮助我们更好的管理应用的配置，减少错误的发生。本质上还是做了数据的校验，只是校验的内容是配置项。配合其他库使用，会更加方便。</p></blockquote><p>比如，你可以将这些配置与上面举例的FastAPI结合使用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI(title=settings.app_name, version=settings.app_version)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;app_name&quot;</span>: settings.app_name, <span class="string">&quot;version&quot;</span>: settings.app_version&#125;</span><br></pre></td></tr></table></figure><p>这样可以使你的应用配置更加规范和灵活，同时提高代码的可维护性和安全性。</p><blockquote><p>在实际工程中可以单独开一个文件夹来存放用<code>Pydantic</code>规范好的数据模型，更好做数据类型的统一管理。</p></blockquote><ul><li><strong>数据序列化和反序列化</strong>：将数据在不同格式之间转换，如JSON和Python对象之间的转换。Pydantic 提供了丰富的序列化功能，具体如下：<ol><li><strong>转换为 Python 字典（包含相关 Python 对象）</strong>：可将模型转换为由相关 Python 对象组成的 Python 字典。</li><li><strong>转换为可 JSON 序列化的 Python 字典</strong>：能把模型转换为仅由“可转换为 JSON 的”类型组成的 Python 字典。</li><li><strong>转换为 JSON 字符串</strong>：支持将模型直接转换为 JSON 字符串。</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    signup_date: datetime</span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 反序列化：JSON转Python对象</span></span><br><span class="line"><span class="comment"># 从JSON字符串创建模型实例</span></span><br><span class="line">user_data = <span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;John Doe&quot;, &quot;signup_date&quot;: &quot;2023-01-01T12:00:00&quot;, &quot;tags&quot;: [&quot;premium&quot;, &quot;active&quot;]&#125;&#x27;</span></span><br><span class="line">user = User.model_validate_json(user_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;反序列化结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(user)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;用户ID: <span class="subst">&#123;user.<span class="built_in">id</span>&#125;</span>, 名称: <span class="subst">&#123;user.name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;注册日期类型: <span class="subst">&#123;<span class="built_in">type</span>(user.signup_date)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 序列化功能展示</span></span><br><span class="line">user_dict = user.model_dump()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n转换为包含Python对象的字典:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(user_dict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典中的日期类型: <span class="subst">&#123;<span class="built_in">type</span>(user_dict[<span class="string">&#x27;signup_date&#x27;</span>])&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">json_compatible_dict = user.model_dump(exclude_unset=<span class="literal">True</span>, by_alias=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n转换为可JSON序列化的字典:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(json_compatible_dict)</span><br><span class="line"></span><br><span class="line">user_json = user.model_dump_json()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n转换为JSON字符串:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(user_json)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 高级用法：自定义JSON编码器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomUser</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    signup_date: datetime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">        json_encoders = &#123;</span><br><span class="line">            datetime: <span class="keyword">lambda</span> v: v.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">custom_user = CustomUser(<span class="built_in">id</span>=<span class="number">2</span>, name=<span class="string">&quot;Jane Smith&quot;</span>, signup_date=datetime.now())</span><br><span class="line">custom_json = custom_user.model_dump_json(indent=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n自定义JSON编码器结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(custom_json)</span><br></pre></td></tr></table></figure><p>这些功能使得Pydantic成为处理数据验证和序列化的强大工具，特别适合在API开发、配置管理和数据交换场景中使用。</p><blockquote><p>序列化和反序列化的功能在实际工程中用的比较多，比如在Web应用中，客户端发送的请求数据是JSON格式的，服务器端需要将JSON格式的数据转换为Python对象进行处理，处理完成后再转换为JSON格式返回给客户端。</p></blockquote><ul><li><strong>数值校验</strong>：对数值类型的字段进行校验，确保输入的数值在指定的范围内。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, field_validator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    value: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @field_validator(<span class="params"><span class="string">&#x27;value&#x27;</span>, mode=<span class="string">&#x27;before&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cast_ints</span>(<span class="params">cls, value: <span class="type">Any</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;这是数字&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;这是字符串&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Model(value=<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">#&gt; value=&#x27;这是字符串&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Model(value=<span class="number">1</span>))</span><br><span class="line"><span class="comment">#&gt; value=&#x27;这是数字&#x27;</span></span><br></pre></td></tr></table></figure><p>这个示例更贴近实际应用场景，特别是在用户注册、表单提交等需要严格数据验证的场景中非常有用。通过Pydantic，我们可以轻松实现复杂的验证逻辑，同时保持代码的清晰和可维护性。</p><blockquote><p>特意给了个奇怪的示例，其实是想说，既然我可以用这个来做判断，就可以做转换🤭，如果我把”这是字符串”和”这是数字”转换成对应的异常信息返回、或者是类型转换代码，是不是可以做到统一输入了，即使收到的数据类型不同也不会影响后续的代码运行结果。</p></blockquote><ul><li><strong>数据清洗和转换</strong>：清理和转换输入数据，使其符合预期格式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    value: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据清洗和转换，将字符串转换为整数</span></span><br><span class="line">data = Data(value=<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data.value)</span><br></pre></td></tr></table></figure><blockquote><p>当然Pydantic本身也具备自动转换数据类型的能力，上面这个例子就是把字符串”42”转换为整数42。Pydantic很强大，有很多潜在的能力等待大家发掘，具体可以看看Pydantic官网，这里就不把全部特性都放出来了，篇幅很大。</p></blockquote><h2 id="二、安装与基础配置"><a href="#二、安装与基础配置" class="headerlink" title="二、安装与基础配置"></a>二、安装与基础配置</h2><h3 id="2-1-安装Pydantic"><a href="#2-1-安装Pydantic" class="headerlink" title="2.1 安装Pydantic"></a>2.1 安装Pydantic</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pydantic</span><br></pre></td></tr></table></figure><p><code>Pydantic</code>也支持<code>conda</code>安装，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pydantic -c conda-forge</span><br></pre></td></tr></table></figure><p><strong>Pydantic具有以下可选依赖项：</strong></p><ul><li>email：由emailValidator程序包提供的电子邮件验证。</li><li>timezone：由tzdata程序包提供的IANA时区数据库的备用选项。<br>要与Pydantic一起安装可选的依赖项：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以只安装email验证器</span></span><br><span class="line">pip install <span class="string">&#x27;pydantic[email]&#x27;</span></span><br><span class="line"><span class="comment"># 也可以都安装，自己选择即可</span></span><br><span class="line">pip install <span class="string">&#x27;pydantic[email,timezone]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="三、核心功能与优势"><a href="#三、核心功能与优势" class="headerlink" title="三、核心功能与优势"></a>三、核心功能与优势</h2><p>最后就把Pydantic的核心功能和优势总结一下，上面的应用场景其实都有涉及，大家看完下面的功能会有更清晰的认识。</p><h3 id="3-1-数据验证"><a href="#3-1-数据验证" class="headerlink" title="3.1 数据验证"></a>3.1 数据验证</h3><p>Pydantic 提供了强大而灵活的数据验证机制，确保输入数据符合预期格式和约束。</p><ul><li><strong>内置验证器</strong>：提供了丰富的预定义验证器，如 <code>EmailStr</code>（邮箱验证）、<code>UrlStr</code>（URL验证）、<code>constr</code>（字符串约束）、<code>conint</code>（整数约束）等，覆盖了大多数常见验证场景。</li><li><strong>自定义验证器</strong>：通过 <code>@validator</code> 装饰器可以轻松创建自定义验证逻辑，支持字段级和模型级验证，还可以访问其他字段的值进行联合验证。</li><li><strong>验证错误处理</strong>：验证失败时会生成结构化的<code>ValidationError</code>对象，包含详细的错误信息（字段、错误类型、错误消息），便于定位和处理问题。</li></ul><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr, field_validator, ValidationError</span><br><span class="line"><span class="keyword">from</span> pydantic_core.core_schema <span class="keyword">import</span> FieldValidationInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    email: EmailStr</span><br><span class="line">    age: <span class="built_in">int</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @field_validator(<span class="params"><span class="string">&#x27;age&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age_must_be_adult</span>(<span class="params">cls, v</span>):</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">18</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;必须是成年人&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"><span class="meta">    @field_validator(<span class="params"><span class="string">&#x27;password&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">password_must_be_strong</span>(<span class="params">cls, v</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(v) &lt; <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;密码长度必须至少为8位&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(c.isupper() <span class="keyword">for</span> c <span class="keyword">in</span> v):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;密码必须包含至少一个大写字母&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证失败示例</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    User(email=<span class="string">&#x27;invalid-email&#x27;</span>, age=<span class="number">16</span>, password=<span class="string">&#x27;weak&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ValidationError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.json())</span><br></pre></td></tr></table></figure><h3 id="3-2-类型提示与自动转换"><a href="#3-2-类型提示与自动转换" class="headerlink" title="3.2 类型提示与自动转换"></a>3.2 类型提示与自动转换</h3><p>Pydantic 充分利用 Python 的类型提示系统，提供静态类型检查和运行时类型转换的双重保障。</p><ul><li><strong>支持的类型</strong>：全面支持 Python 内置类型（<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code> 等）、标准库类型（<code>datetime</code>, <code>date</code>, <code>UUID</code> 等）以及自定义类型。</li><li><strong>自动类型转换</strong>：智能地将输入数据转换为声明的类型，例如将字符串形式的数字转换为整数，将ISO格式的字符串转换为 <code>datetime</code> 对象。</li><li><strong>复杂类型处理</strong>：优雅处理嵌套列表、字典、集合等复杂数据结构，支持递归类型定义和类型参数化。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    start_time: datetime  <span class="comment"># 自动将字符串转换为datetime</span></span><br><span class="line">    participants: <span class="type">List</span>[<span class="built_in">str</span>]  <span class="comment"># 支持列表类型</span></span><br><span class="line">    metadata: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]] = <span class="literal">None</span>  <span class="comment"># 支持可选字段和字典类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型转换示例</span></span><br><span class="line">event = Event(</span><br><span class="line">    <span class="built_in">id</span>=<span class="string">&#x27;123&#x27;</span>,  <span class="comment"># 字符串自动转换为整数</span></span><br><span class="line">    name=<span class="string">&#x27;技术研讨会&#x27;</span>,</span><br><span class="line">    start_time=<span class="string">&#x27;2023-12-01T10:00:00&#x27;</span>,  <span class="comment"># 字符串自动转换为datetime</span></span><br><span class="line">    participants=[<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>],</span><br><span class="line">    metadata=&#123;<span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;线上&#x27;</span>, <span class="string">&#x27;organizer&#x27;</span>: <span class="string">&#x27;技术部&#x27;</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(event.model_dump())</span><br></pre></td></tr></table></figure><h3 id="3-3-模型定义与管理"><a href="#3-3-模型定义与管理" class="headerlink" title="3.3 模型定义与管理"></a>3.3 模型定义与管理</h3><p>Pydantic 模型是数据结构和业务逻辑的核心载体，支持多种高级特性。</p><ul><li><strong>基础模型</strong>：通过继承 <code>BaseModel</code> 创建，字段使用类型注解定义，支持默认值、可选字段和字段校验器。</li><li><strong>嵌套模型</strong>：模型字段可以是另一个模型类型，实现数据结构的层级化和模块化，便于处理复杂数据。</li><li><strong>继承模型</strong>：支持模型间的继承，子类模型自动继承父类的字段和验证器，也可以覆盖或扩展父类行为。</li><li><strong>泛型模型</strong>：支持泛型类型，提高代码复用性，适用于处理不同类型但结构相似的数据。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    city: <span class="built_in">str</span></span><br><span class="line">    street: <span class="built_in">str</span></span><br><span class="line">    zip_code: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Contact</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    person: Person  <span class="comment"># 嵌套Person模型</span></span><br><span class="line">    address: Address  <span class="comment"># 嵌套Address模型</span></span><br><span class="line">    phone: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    employee_id: <span class="built_in">str</span></span><br><span class="line">    department: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泛型模型</span></span><br><span class="line">data_type = TypeVar(<span class="string">&#x27;data_type&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaginatedResponse</span>(BaseModel, <span class="type">Generic</span>[data_type]):</span><br><span class="line">    total: <span class="built_in">int</span></span><br><span class="line">    page: <span class="built_in">int</span></span><br><span class="line">    page_size: <span class="built_in">int</span></span><br><span class="line">    items: <span class="type">List</span>[data_type]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用泛型模型</span></span><br><span class="line">users = [Person(name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">30</span>), Person(name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">25</span>)]</span><br><span class="line">response = PaginatedResponse[Person](total=<span class="number">2</span>, page=<span class="number">1</span>, page_size=<span class="number">10</span>, items=users)</span><br><span class="line"><span class="comment"># 输出模型内容</span></span><br><span class="line"><span class="built_in">print</span>(response.model_dump())</span><br></pre></td></tr></table></figure><h3 id="3-4-与其他库的兼容性"><a href="#3-4-与其他库的兼容性" class="headerlink" title="3.4 与其他库的兼容性"></a>3.4 与其他库的兼容性</h3><p>Pydantic 设计为与其他流行 Python 库无缝集成，增强开发体验和效率。</p><ul><li><strong>与FastAPI集成</strong>：FastAPI 原生支持 Pydantic 模型，自动用于请求参数验证和响应格式化，大幅减少重复代码。</li><li><strong>与Django&#x2F;Flask集成</strong>：可作为表单验证和API数据处理的补充，在保持框架原生体验的同时提升数据验证能力。</li><li><strong>与Pandas&#x2F;Numpy集成</strong>：支持与数据科学库的数据结构互转，方便在数据处理管道中进行数据验证和清洗。</li></ul><p>示例（与FastAPI集成）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    is_offer: <span class="built_in">bool</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&#x27;/items/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_item</span>(<span class="params">item: Item</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;item_name&#x27;</span>: item.name, <span class="string">&#x27;item_price&#x27;</span>: item.price&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hydra使用指南</title>
      <link href="/2025/09/02/Hydra%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2025/09/02/Hydra%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Hydra是一款开源Python框架，专为简化科研项目及其他复杂应用的开发而设计。其核心优势在于支持动态构建分层配置体系——既可通过组合方式创建层级结构，又能借助配置文件和命令行进行灵活调整。该名称源自其“多头并进”的特性：就像水蛇分叉般能同时运行多个相似任务，完美诠释了“众手齐发力”的开发理念。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li>支持多源组合的层次化配置管理：可从多个来源（文件、环境变量、命令行等）加载并组合配置，形成层次化的配置结构</li><li>命令行参数配置覆盖：支持通过命令行参数直接指定或覆盖配置值，提供灵活的配置方式</li><li>动态命令行补全：提供智能的命令行选项补全功能，提升开发体验和效率</li><li>本地与远程执行支持：支持在本地运行应用程序，或配置并启动远程执行环境</li><li>多参数作业并行执行：支持通过单个命令运行具有不同参数组合的多个作业，实现高效的参数空间探索</li></ol><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install hydra-core --upgrade</span><br></pre></td></tr></table></figure><blockquote><p>这里安装的时候要注意一下！！因为导入的包是hydra，所以会下意识的安装hydra，而不是hydra-core，导致安装不成功。（因为我自己去安装的时候有出现这个问题）</p></blockquote><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><h4 id="1-基本用法（命令行参数）"><a href="#1-基本用法（命令行参数）" class="headerlink" title="1. 基本用法（命令行参数）"></a>1. 基本用法（命令行参数）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> DictConfig, OmegaConf</span><br><span class="line"><span class="keyword">import</span> hydra</span><br><span class="line"></span><br><span class="line"><span class="meta">@hydra.main(<span class="params">version_base=<span class="literal">None</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_app</span>(<span class="params">cfg: DictConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(OmegaConf.to_yaml(cfg))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_app()</span><br></pre></td></tr></table></figure><p>在本示例中，Hydra创建一个空的<code>cfg</code>对象，并将其传递给带有<code>@hydra.main</code>注解的函数。</p><p>你可以通过命令行添加配置值，<code>+</code>表示该字段是新的。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python my_app.py +db.driver=mysql +db.user=omry +db.password=secret</span><br></pre></td></tr></table></figure><p>当你在命令行中输入上述命令时，Hydra会将<code>db.driver</code>、<code>db.user</code>和<code>db.password</code>添加到<code>cfg</code>对象中。</p><p>你可以在Python代码中使用<code>cfg</code>对象来访问这些配置值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_app</span>(<span class="params">cfg: DictConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(cfg.db.driver)</span><br><span class="line">    <span class="built_in">print</span>(cfg.db.user)</span><br><span class="line">    <span class="built_in">print</span>(cfg.db.password)</span><br></pre></td></tr></table></figure><p>在本示例中，<code>my_app</code>函数接收一个<code>DictConfig</code>对象作为参数，该对象包含了从命令行添加的配置值。通过<code>cfg.db.driver</code>、<code>cfg.db.user</code>和<code>cfg.db.password</code>，你可以访问到相应的配置值。</p><h4 id="2-配置文件（config-yaml）"><a href="#2-配置文件（config-yaml）" class="headerlink" title="2. 配置文件（config.yaml）"></a>2. 配置文件（config.yaml）</h4><p>你也可以在配置文件中定义默认值。例如，在文件夹<code>conf</code>下创建一个<code>config.yaml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">omry</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure><p>然后，在Python代码中使用<code>@hydra.main</code>注解时，指定配置文件的路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@hydra.main(<span class="params">version_base=<span class="literal">None</span>, config_path=<span class="string">&quot;./conf&quot;</span>, config_name=<span class="string">&quot;config&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_app</span>(<span class="params">cfg: DictConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(OmegaConf.to_yaml(cfg))</span><br></pre></td></tr></table></figure><p>当你启动应用的时候，Hydra会自动加载<code>conf</code>文件夹下的<code>config.yaml</code>文件。</p><blockquote><p><code>config_path</code>是配置文件的路径，<code>config_name</code>是配置文件的名称。注意：这里的<code>config_path</code>是相对于Python文件的路径，所以这里是<code>./conf</code>，如果是绝对路径，就不需要加<code>./</code>了。</p></blockquote><p>您可以从命令行覆盖已加载配置中的值，<strong>不用加<code>+</code>作为前缀，直接写键值对即可</strong>。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python my_app.py db.driver=postgresql</span><br></pre></td></tr></table></figure><p>在本示例中，<code>db.driver</code>的值被覆盖为<code>postgresql</code>。</p><p>你可以在命令行中添加多个配置值，它们会被合并到<code>cfg</code>对象中。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python my_app.py db.driver=postgresql db.user=postgres</span><br></pre></td></tr></table></figure><p>在本示例中，<code>db.driver</code>的值被覆盖为<code>postgresql</code>，<code>db.user</code>的值被设置为<code>postgres</code>。</p><p>如果配置中已存在某个配置值，则使用++来覆盖该值，否则添加该值。例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 覆盖存在的配置值</span><br><span class="line">$ python my_app.py ++db.password=<span class="number">1234</span></span><br><span class="line"></span><br><span class="line"># 添加一个新的配置值</span><br><span class="line">$ python my_app.py ++db.timeout=<span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="3-配置对象"><a href="#3-配置对象" class="headerlink" title="3.配置对象"></a>3.配置对象</h4><p>上面两个小节主要展示了<code>hydra</code>的使用方式，一个是在命令行中读取，一个是在配置文件中读取。</p><p>下面这个小节主要展示了<code>hydra</code>的配置对象的这一特点。即可以通过对象的方式来访问配置文件中的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node:</span>                         <span class="comment"># yaml的配置是分层的</span></span><br><span class="line">  <span class="attr">loompa:</span> <span class="number">10</span>                  <span class="comment"># 简单值</span></span><br><span class="line">  <span class="attr">zippity:</span> <span class="string">$&#123;node.loompa&#125;</span>     <span class="comment"># 插值，这里是引用node.loompa的值</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">do:</span> <span class="string">&quot;oompa $&#123;node.loompa&#125;&quot;</span>  <span class="comment"># 字符串插值，这里是引用node.loompa的值</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">waldo:</span> <span class="string">???</span>                  <span class="comment"># 缺失值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> DictConfig, OmegaConf</span><br><span class="line"><span class="keyword">import</span> hydra</span><br><span class="line"></span><br><span class="line"><span class="meta">@hydra.main(<span class="params">version_base=<span class="literal">None</span>, config_path=<span class="string">&quot;.&quot;</span>, config_name=<span class="string">&quot;config&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_app</span>(<span class="params">cfg: DictConfig</span>):</span><br><span class="line">    <span class="keyword">assert</span> cfg.node.loompa == <span class="number">10</span>          <span class="comment"># 属性方式访问</span></span><br><span class="line">    <span class="keyword">assert</span> cfg[<span class="string">&quot;node&quot;</span>][<span class="string">&quot;loompa&quot;</span>] == <span class="number">10</span>    <span class="comment"># 字典方式访问</span></span><br><span class="line">    <span class="keyword">assert</span> cfg.node.zippity == <span class="number">10</span>         <span class="comment"># 插值方式访问</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(cfg.node.zippity, <span class="built_in">int</span>)  <span class="comment"># 插值方式访问的值是int类型</span></span><br><span class="line">    <span class="keyword">assert</span> cfg.node.do == <span class="string">&quot;oompa 10&quot;</span>      <span class="comment"># 字符串插值方式访问</span></span><br><span class="line">    cfg.node.waldo                        <span class="comment"># 缺失值访问，会报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_app()</span><br></pre></td></tr></table></figure><blockquote><p>运行上面的代码报错是很正常的，因为<code>waldo</code>是一个缺失值，没有在配置文件中定义，所以会报错。要正确跑通只需要把<code>cfg.node.waldo</code>注释掉即可。</p></blockquote><p>通过上面的例子可以了解到，<code>hydra</code>可以通过对象的方式对配置文件的键值对进行封装，从而可以通过使用对象访问属性的方式来获取配置值。</p><h4 id="4-配置组文件"><a href="#4-配置组文件" class="headerlink" title="4.配置组文件"></a>4.配置组文件</h4><p>假如你想在PostgreSQL和MySQL这俩数据库上给应用程序做个基准测试，这时候就可以用配置组。</p><p>配置组，就是一个有一堆有效选项的命名组。要是你选了个不存在的配置选项，就会报错，报错信息里还会把有效的选项都列出来。</p><p>要创建配置组，请创建一个目录（例如db），用于存放每个数据库配置选项的文件。由于我们预期会有多个配置组，因此我们将所有配置文件主动移动到conf目录中。</p><p>示例的文件树如下:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─ conf</span><br><span class="line">│  └─ db</span><br><span class="line">│      ├─ mysql.yaml</span><br><span class="line">│      └─ postgresql.yaml</span><br><span class="line">└── my_app.py</span><br></pre></td></tr></table></figure><p>在mysql.yaml中，我们可以这样配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">omry</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure><p>在postgresql.yaml中，我们可以这样配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">postgres_user</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">drowssap</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>由于我们已将所有配置文件移至conf目录，因此需要通过config_path参数告知Hydra如何定位这些配置。config_path是相对于my_app.py的目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> DictConfig, OmegaConf</span><br><span class="line"><span class="keyword">import</span> hydra</span><br><span class="line"></span><br><span class="line"><span class="meta">@hydra.main(<span class="params">version_base=<span class="literal">None</span>, config_path=<span class="string">&quot;conf&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_app</span>(<span class="params">cfg: DictConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(OmegaConf.to_yaml(cfg))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_app()</span><br></pre></td></tr></table></figure><p>运行my_app.py而<strong>不请求配置</strong>将打印空的配置。</p><blockquote><p>运行my_app.py而<strong>不请求配置</strong>将打印空的配置。这是因为我们没有在命令行中指定任何配置，也没有在配置文件中定义默认值。我们虽然在配置文件中定义了配置项，但是并没有说是使用<code>db.mysql</code>还是<code>db.postgresql</code>，所以打印为空。</p></blockquote><p>从配置组中选择一个项，其<code>+GROUP=OPTION</code>，例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python my_app.py +db=postgresql</span><br><span class="line"><span class="function">db:</span></span><br><span class="line"><span class="function">  <span class="title">driver</span>: <span class="title">postgresql</span></span></span><br><span class="line"><span class="function">  <span class="title">password</span>: <span class="title">drowssap</span></span></span><br><span class="line"><span class="function">  <span class="title">timeout</span>: 10</span></span><br><span class="line"><span class="function">  <span class="title">user</span>: <span class="title">postgres_user</span></span></span><br></pre></td></tr></table></figure><blockquote><p>上面这个示例就是通过<code>+db=postgresql</code>来选择<code>db.postgresql</code>这个配置组。因此得到的就是<code>postgresql.yaml</code>文件中的配置项。反之同理，通过<code>+db=mysql</code>来选择<code>db.mysql</code>这个配置组。因此得到的就是<code>mysql.yaml</code>文件中的配置项。</p></blockquote><p>可以在生成的配置中覆盖单个值，也就是带<code>+</code>和不带<code>+</code>的组合使用！！</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python my_app.py +db=postgresql db.user=postgres</span><br><span class="line"><span class="function">db:</span></span><br><span class="line"><span class="function">  <span class="title">driver</span>: <span class="title">postgresql</span></span></span><br><span class="line"><span class="function">  <span class="title">password</span>: <span class="title">drowssap</span></span></span><br><span class="line"><span class="function">  <span class="title">timeout</span>: 10</span></span><br><span class="line"><span class="function">  <span class="title">user</span>: <span class="title">postgres</span></span></span><br></pre></td></tr></table></figure><blockquote><p>上面这个示例就是先选择<code>db.postgresql</code>这个配置组，然后在这个配置组中覆盖<code>db.user</code>这个配置项的值为<code>postgres</code>。因此得到的就是<code>postgresql.yaml</code>文件中的配置项，但是<code>user</code>的值被覆盖为<code>postgres</code>。</p></blockquote><h4 id="5-选择默认的配置"><a href="#5-选择默认的配置" class="headerlink" title="5.选择默认的配置"></a>5.选择默认的配置</h4><p>通过上述配置组文件的案例我们可以知道，我们需要通过<code>+db=mysql</code>来选择<code>db.mysql</code>这个配置组，不选择的时候返回的是空的。但是<code>hydra</code>可以在<code>config.yaml</code>中定义默认值，这样就可以在不指定<code>+db</code>的情况下，默认选择<code>db.mysql</code>这个配置组。</p><p>我们只需要创建一个<code>config.yaml</code>文件，在这个文件中定义默认值，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">db:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p>请记住要指定config_name：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> DictConfig, OmegaConf</span><br><span class="line"><span class="keyword">import</span> hydra</span><br><span class="line"></span><br><span class="line"><span class="meta">@hydra.main(<span class="params">version_base=<span class="literal">None</span>, config_path=<span class="string">&quot;conf&quot;</span>, config_name=<span class="string">&quot;config&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_app</span>(<span class="params">cfg: DictConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(OmegaConf.to_yaml(cfg))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_app()</span><br></pre></td></tr></table></figure><p>运行更新后的应用程序时，默认情况下将加载MySQL。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python my_app.py</span><br><span class="line"><span class="function">db:</span></span><br><span class="line"><span class="function">  <span class="title">driver</span>: <span class="title">mysql</span></span></span><br><span class="line"><span class="function">  <span class="title">password</span>: <span class="title">secret</span></span></span><br><span class="line"><span class="function">  <span class="title">user</span>: <span class="title">omry</span></span></span><br></pre></td></tr></table></figure><p>默认值列表中可以包含多个项目，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">db:</span> <span class="string">mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">db/mysql/engine:</span> <span class="string">innodb</span></span><br></pre></td></tr></table></figure><p>如果存在多个默认值，那么默认值按以下顺序排列：</p><ul><li>当多个配置中定义了相同的配置项时，按配置加载顺序，最后加载的配置项值会覆盖之前加载的配置项值。</li><li>当多个配置文件对同一个字典进行配置时，按配置文件加载顺序，最后加载的配置文件中的字典值会覆盖之前配置文件中的字典值。</li></ul><p>可以通过在默认值列表中条目的前缀添加~来<strong>删除</strong>该条目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python my_app.py ~db</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Hydra作为一款强大的配置管理框架，为复杂应用程序和科研项目提供了优雅的配置解决方案。其核心优势在于支持层次化、多源组合的配置管理，同时提供灵活的命令行参数覆盖和智能补全功能，极大提升了开发效率和配置灵活性。Hydra通过其强大而灵活的配置管理能力，帮助开发者从繁琐的配置工作中解放出来，更专注于核心业务逻辑和算法创新，是现代复杂应用开发和科研实验管理的得力工具。</p><blockquote><p>其实我发现这个模块也是因为看了<code>Time-R1</code>这个项目的源码才知道的，这个项目中使用了<code>hydra</code>来管理配置文件，所以我才去学习了一下<code>hydra</code>的使用🌈。所以学习源码还是有用的，能从中发现一些很有趣且有用的模块，帮助提升自己的开发和研发能力，提高效率！！</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux定时任务使用(cron)</title>
      <link href="/2025/09/02/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8-cron/"/>
      <url>/2025/09/02/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8-cron/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么需要定时任务？"><a href="#一、为什么需要定时任务？" class="headerlink" title="一、为什么需要定时任务？"></a>一、为什么需要定时任务？</h2><p>这个其实是我在工作当中遇到的一个问题，我需要在非工作时间，比如晚上0点，自动执行一个脚本，来重启算法服务。这其实也是卡在一个其他客户不用上班的时间，工作时间点肯定就不能进行算法服务的重启操作了，这对于客户的损失是比较大的。因此，借此场景来学习Linux定时任务的设置。</p><p>Linux设置定时任务的好处如下：</p><ul><li>设置自动化重复工作，解放双手</li><li>保障系统维护在非工作时间执行</li><li>确保关键任务按时完成，避免人为遗忘</li></ul><h2 id="二、核心工具：cron与at"><a href="#二、核心工具：cron与at" class="headerlink" title="二、核心工具：cron与at"></a>二、核心工具：cron与at</h2><p>Linux系统提供了多种定时任务工具，其中最常用的有cron和at，此外还有batch、systemd-timer等工具。不过目前主要使用的是cron和at。因此，下面主要介绍这两个工具的使用。</p><h3 id="2-1-cron：最常用的周期性定时任务系统"><a href="#2-1-cron：最常用的周期性定时任务系统" class="headerlink" title="2.1 cron：最常用的周期性定时任务系统"></a>2.1 cron：最常用的周期性定时任务系统</h3><p><strong>什么是cron？</strong></p><p>cron是Linux系统中最经典、最常用的定时任务调度器，用于周期性执行命令或脚本。它通过crontab文件定义任务，由cron守护进程（crond）在后台持续运行并检查任务执行时间，其中系统级任务存储在&#x2F;etc&#x2F;crontab和&#x2F;etc&#x2F;cron.d&#x2F;目录下，用户级任务通过crontab命令管理。</p><p><strong>工作原理：</strong></p><ol><li><strong>用户创建或编辑任务</strong>：用户通过 <code>crontab</code> 命令创建或编辑定时任务。执行 <code>crontab -e</code> 命令时，系统会调用默认的文本编辑器打开一个临时文件，用户可以在其中按照 <code>cron</code> 的语法格式添加、修改或删除定时任务。编辑完成并保存退出后，该文件内容会被处理成合法的定时任务信息。</li><li><strong>任务存储</strong>：经过处理的定时任务信息会被保存到 <code>/var/spool/cron/</code> 目录下以用户名命名的专属文件中。每个用户的定时任务都独立存储在该目录下对应的文件里，保证了不同用户任务的隔离性。</li><li><strong>守护进程检查</strong>：<code>crond</code> 守护进程在系统后台持续运行，每分钟会对 <code>/var/spool/cron/</code> 目录下的所有用户专属文件，以及 <code>/etc/crontab</code> 和 <code>/etc/cron.d/</code> 目录下的系统级任务文件进行一次全面检查。它会解析每个任务的时间表达式，判断是否有任务到达执行时间。</li><li><strong>任务执行</strong>：当 <code>crond</code> 守护进程检查到某个任务到达指定的执行时间时，会 <code>fork</code> 一个子进程来执行该任务。之所以创建子进程，是为了保证 <code>crond</code> 守护进程本身可以继续正常运行，不受任务执行的影响。任务执行完成后，子进程会自动结束。</li></ol><p><strong>优点：</strong></p><ul><li>支持复杂的时间表达式，可<strong>精确到分钟级别</strong></li><li>任务执行结果可通过邮件通知（默认配置）</li><li>支持系统级和用户级任务分离</li><li>几乎所有Linux发行版都预装并默认启用</li></ul><p><strong>缺点：</strong></p><ul><li>配置相对复杂，需要记忆特殊字符的含义</li><li>不支持任务依赖关系</li><li>当系统关机或重启时，错过的任务不会自动执行（需配合anacron解决）</li></ul><p><strong>适用场景：</strong></p><ul><li>需要定期执行的系统维护任务（如日志清理、备份）</li><li>周期性的数据处理或报表生成</li><li>定时启动&#x2F;关闭服务或应用程序</li></ul><p><strong>crontab命令：管理定时任务的入口</strong></p><ul><li><code>crontab -e</code>：编辑当前用户的定时任务</li><li><code>crontab -l</code>：列出当前用户的定时任务</li><li><code>crontab -r</code>：删除当前用户的所有定时任务</li><li><code>crontab -u username -e</code>：编辑指定用户的定时任务（需要root权限）</li></ul><h3 id="2-2-at：一次性定时任务工具"><a href="#2-2-at：一次性定时任务工具" class="headerlink" title="2.2 at：一次性定时任务工具"></a>2.2 at：一次性定时任务工具</h3><p><strong>什么是at？</strong></p><p>at 是用于执行<strong>一次性定时任务的工具</strong>，可在指定时间点执行一次命令或脚本。与 cron 不同，at 任务执行完毕后会自动删除，由 atd 守护进程负责管理和执行。</p><p><strong>工作原理：</strong></p><ol><li><strong>用户创建任务</strong>：用户使用 <code>at</code> 命令指定任务的执行时间和要执行的命令。<code>at</code> 命令支持多种时间指定方式，如绝对时间（例如 <code>at 23:00 tomorrow</code>）和相对时间（例如 <code>at now + 30 minutes</code>）。执行命令后，用户需要输入要执行的具体命令，输入完成后按 <code>Ctrl + D</code> 结束输入。</li><li><strong>任务存储</strong>：输入完成后，系统会对任务信息进行处理，将任务保存到 <code>/var/spool/at/</code> 目录下。任务会被存储为一个文件，文件名包含任务的唯一标识，确保每个任务都能被准确识别和管理。</li><li><strong>守护进程检查</strong>：<code>atd</code> 守护进程在系统后台持续运行，每分钟会检查 <code>/var/spool/at/</code> 目录下的任务文件。它会解析每个任务文件中的时间信息，判断是否有任务到达执行时间。</li><li><strong>任务执行与清理</strong>：当 <code>atd</code> 守护进程检查到某个任务到达指定的执行时间时，会 <code>fork</code> 一个子进程来执行该任务。这样可以保证 <code>atd</code> 守护进程本身能够继续正常运行，不受任务执行的影响。任务执行完成后，<code>atd</code> 会自动删除对应的任务文件，清理任务记录。</li></ol><p>这里给个一个简单的 <code>at</code> 命令使用示例，该示例会在明天 10 点执行关机命令（使用<code>at</code>要确保Linux已经安装了这个命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at 10:00 tomorrow <span class="comment"># 先执行命令</span></span><br><span class="line">shutdown -h now <span class="comment"># 然后输入到时间点要执行的命令</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>语法简单直观，容易学习和使用</li><li>适合<strong>临时的、一次性</strong>的任务调度</li><li>支持多种时间指定方式（如绝对时间、相对时间）</li></ul><p><strong>缺点：</strong></p><ul><li>不支持周期性任务</li><li>任务执行结果默认通过邮件发送，可能被忽略</li><li>当系统关机或重启时，错过的任务不会自动执行</li></ul><p><strong>适用场景：</strong></p><ul><li>延迟执行某个命令（如30分钟后关闭系统）</li><li>在特定时间点执行一次性数据处理</li><li>安排在非工作时间执行的临时任务</li></ul><p><strong>与cron的主要区别：</strong></p><ul><li>cron用于周期性任务，at用于一次性任务</li><li>cron任务会被保存并重复执行，at任务执行后自动删除</li><li>cron配置相对复杂，at语法更简单直观</li></ul><h3 id="2-3-其他定时任务工具"><a href="#2-3-其他定时任务工具" class="headerlink" title="2.3 其他定时任务工具"></a>2.3 其他定时任务工具</h3><p><strong>batch</strong> 是一个用于在系统负载较低时执行一次性任务的工具。它与 <code>at</code> 类似，但不指定具体执行时间，而是在系统负载低于某个阈值时才执行，适合用于执行资源密集型任务，以此避免影响系统正常运行。</p><p><strong>systemd-timer：新时代的定时任务方案</strong>：随着systemd的普及，systemd-timer逐渐成为替代cron的新选择。它支持更精确的时间控制、任务依赖关系和事件触发，配置灵活，但学习曲线较陡峭。</p><h2 id="三、cron基础使用教程"><a href="#三、cron基础使用教程" class="headerlink" title="三、cron基础使用教程"></a>三、cron基础使用教程</h2><p>目前我在工作中所使用的也是cron居多，基本上都是要在服务器上执行一些定时任务，这个<code>cron</code>使用起来较为简单，很快就可以把一个定时任务给编写出来。下面具体介绍一下<code>cron</code>的基础使用方式。</p><h3 id="3-1-基本语法与格式"><a href="#3-1-基本语法与格式" class="headerlink" title="3.1 基本语法与格式"></a>3.1 基本语法与格式</h3><p><code>cron</code>的配置文件遵循严格的语法格式，每行代表一个定时任务，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分 时 日 月 周 要执行的命令</span><br></pre></td></tr></table></figure><h4 id="时间字段详细解析"><a href="#时间字段详细解析" class="headerlink" title="时间字段详细解析"></a>时间字段详细解析</h4><ul><li><strong>分</strong>：取值范围 0-59，表示分钟</li><li><strong>时</strong>：取值范围 0-23，表示小时</li><li><strong>日</strong>：取值范围 1-31，表示日期</li><li><strong>月</strong>：取值范围 1-12，表示月份</li><li><strong>周</strong>：取值范围 0-7（0和7都代表星期日），表示星期几</li></ul><h4 id="特殊字符含义及示例"><a href="#特殊字符含义及示例" class="headerlink" title="特殊字符含义及示例"></a>特殊字符含义及示例</h4><ul><li><code>*</code>：表示所有可能的值，例如在”分”字段使用<code>*</code>，表示每分钟执行一次</li><li><code>/</code>：表示间隔，例如在”分”字段使用<code>*/5</code>，表示每5分钟执行一次</li><li><code>-</code>：表示范围，例如在”时”字段使用<code>9-17</code>，表示9点到17点之间每个小时执行一次</li><li><code>,</code>：表示多个值，例如在”周”字段使用<code>1,3,5</code>，表示周一、周三、周五执行</li></ul><blockquote><p>通过上面时间字段+特殊字符，我们可以组合出各种不同的定时任务。具体怎么组合就要看实际的业务场景了，同时也需要大家发挥自己的创意和经验🌈。下面给出一些组合的示例。</p></blockquote><p><strong>示例效果说明</strong>：</p><ul><li><code>0 8 * * * command</code>：每天早上8点整执行命令</li><li><code>*/15 * * * * command</code>：每15分钟执行一次命令</li><li><code>0 12 * * 1-5 command</code>：周一至周五中午12点执行命令</li><li><code>30 2 1,15 * * command</code>：每月1日和15日凌晨2点30分执行命令</li></ul><h3 id="3-2-常用命令速查"><a href="#3-2-常用命令速查" class="headerlink" title="3.2 常用命令速查"></a>3.2 常用命令速查</h3><h4 id="crontab-e：编辑定时任务"><a href="#crontab-e：编辑定时任务" class="headerlink" title="crontab -e：编辑定时任务"></a><code>crontab -e</code>：编辑定时任务</h4><p><strong>使用步骤</strong>：</p><ol><li>执行命令后，系统会打开默认文本编辑器（通常是vi或nano）</li><li>在编辑器中按照cron语法添加或修改任务</li><li>保存并退出编辑器，任务会自动生效</li></ol><p><strong>效果</strong>：添加或更新用户的定时任务列表</p><h4 id="crontab-l：查看当前任务"><a href="#crontab-l：查看当前任务" class="headerlink" title="crontab -l：查看当前任务"></a><code>crontab -l</code>：查看当前任务</h4><p><strong>使用步骤</strong>：直接在终端执行命令</p><p><strong>效果</strong>：以文本形式显示当前用户的所有定时任务</p><h4 id="crontab-r：删除所有任务"><a href="#crontab-r：删除所有任务" class="headerlink" title="crontab -r：删除所有任务"></a><code>crontab -r</code>：删除所有任务</h4><p><strong>使用步骤</strong>：直接在终端执行命令（注意：此操作不可逆）</p><p><strong>效果</strong>：删除当前用户的所有定时任务</p><p><strong>警告</strong>：使用此命令前请务必先用<code>crontab -l</code>备份任务列表</p><h4 id="crontab-u-username-e：管理其他用户的任务"><a href="#crontab-u-username-e：管理其他用户的任务" class="headerlink" title="crontab -u username -e：管理其他用户的任务"></a><code>crontab -u username -e</code>：管理其他用户的任务</h4><p><strong>使用步骤</strong>：</p><ol><li>以root用户身份执行命令</li><li>编辑指定用户的定时任务</li><li>保存并退出编辑器</li></ol><p><strong>效果</strong>：添加或更新指定用户的定时任务列表</p><p><strong>权限要求</strong>：需要root权限才能管理其他用户的任务</p><h2 id="四、实用示例：服务场景配置"><a href="#四、实用示例：服务场景配置" class="headerlink" title="四、实用示例：服务场景配置"></a>四、实用示例：服务场景配置</h2><p>下面以”每日凌晨2点自动备份数据库”为例，详细演示从<code>crontab -e</code>开始到任务设置完成的完整流程。</p><h3 id="4-1-场景需求"><a href="#4-1-场景需求" class="headerlink" title="4.1 场景需求"></a>4.1 场景需求</h3><p>每天凌晨2点自动备份MySQL数据库，并将备份文件压缩存储到指定目录。</p><h3 id="4-2-实现步骤"><a href="#4-2-实现步骤" class="headerlink" title="4.2 实现步骤"></a>4.2 实现步骤</h3><h4 id="步骤1：创建备份脚本"><a href="#步骤1：创建备份脚本" class="headerlink" title="步骤1：创建备份脚本"></a>步骤1：创建备份脚本</h4><p>首先，我们需要创建一个数据库备份脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建备份脚本文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /backup/scripts</span><br><span class="line">vi /backup/scripts/mysql_backup.sh</span><br></pre></td></tr></table></figure><p>在脚本中添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># MySQL数据库备份脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置信息</span></span><br><span class="line">DB_USER=<span class="string">&quot;root&quot;</span></span><br><span class="line">DB_PASS=<span class="string">&quot;your_password&quot;</span></span><br><span class="line">DB_NAME=<span class="string">&quot;your_database&quot;</span></span><br><span class="line">BKP_DIR=<span class="string">&quot;/backup/mysql&quot;</span></span><br><span class="line">BKP_TIME=$(<span class="built_in">date</span> +%Y%m%d_%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建备份目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$BKP_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行备份</span></span><br><span class="line">mysqldump -u<span class="variable">$DB_USER</span> -p<span class="variable">$DB_PASS</span> <span class="variable">$DB_NAME</span> | gzip &gt; <span class="variable">$BKP_DIR</span>/<span class="variable">$&#123;DB_NAME&#125;</span>_<span class="variable">$&#123;BKP_TIME&#125;</span>.sql.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理7天前的备份文件</span></span><br><span class="line">find <span class="variable">$BKP_DIR</span> -name <span class="string">&quot;<span class="variable">$&#123;DB_NAME&#125;</span>_*.sql.gz&quot;</span> -mtime +7 -delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录日志</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;备份完成: <span class="variable">$BKP_DIR</span>/<span class="variable">$&#123;DB_NAME&#125;</span>_<span class="variable">$&#123;BKP_TIME&#125;</span>.sql.gz&quot;</span> &gt;&gt; /var/log/mysql_backup.log</span><br></pre></td></tr></table></figure><p>保存并退出编辑器，然后为脚本添加执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /backup/scripts/mysql_backup.sh</span><br></pre></td></tr></table></figure><blockquote><p>上面的脚本可以是任何任务，比如我实际业务遇到的算法服务，需要定时调用接口，或者定时调用脚本。下面的步骤是通用的，只需要把要执行的命令替换为实际的命令即可。</p></blockquote><h4 id="步骤2：使用crontab-e添加定时任务"><a href="#步骤2：使用crontab-e添加定时任务" class="headerlink" title="步骤2：使用crontab -e添加定时任务"></a>步骤2：使用<code>crontab -e</code>添加定时任务</h4><p>执行以下命令编辑定时任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>系统会打开默认文本编辑器（通常会是vim，当然我的Linux默认是vim啦）。在编辑器中添加以下行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * /backup/scripts/mysql_backup.sh</span><br></pre></td></tr></table></figure><p>这表示每天凌晨2点（0分2时）执行备份脚本。</p><blockquote><p>这里面的命令是要执行的命令，比如我上面的脚本，就是要执行的命令。也就是说你Linux怎么启动或者重启脚本，这里就怎么写！！本质上就是让Linux帮你在两点钟执行后面那个命令🤖</p></blockquote><h4 id="步骤3：保存并退出编辑器"><a href="#步骤3：保存并退出编辑器" class="headerlink" title="步骤3：保存并退出编辑器"></a>步骤3：保存并退出编辑器</h4><ul><li>如果使用vi编辑器：按<code>Esc</code>键，然后输入<code>:wq</code>并按<code>Enter</code>键保存退出</li><li>如果使用nano编辑器：按<code>Ctrl+O</code>保存，按<code>Ctrl+X</code>退出</li><li>如果使用vim编辑器：按<code>:wq</code>并按<code>Enter</code>键保存退出</li></ul><h4 id="步骤4：验证定时任务是否添加成功"><a href="#步骤4：验证定时任务是否添加成功" class="headerlink" title="步骤4：验证定时任务是否添加成功"></a>步骤4：验证定时任务是否添加成功</h4><p>执行以下命令查看当前用户的定时任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>如果成功添加，会看到类似以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * /backup/scripts/mysql_backup.sh</span><br></pre></td></tr></table></figure><p>给大家看一下Linux实际的输出会是什么样子的？这是我自己设置的重启<code>systemctl</code>服务，重启脚本的时间是0点。</p><p><img src="/../../pictures/cron.png" alt="crontab -l 输出"></p><h2 id="五、避坑指南：常见问题排查"><a href="#五、避坑指南：常见问题排查" class="headerlink" title="五、避坑指南：常见问题排查"></a>五、避坑指南：常见问题排查</h2><ul><li>定时任务不执行？检查这几点<ol><li>命令路径是否正确</li><li>环境变量是否配置</li><li>文件权限是否足够</li></ol></li></ul><blockquote><p>这里要补充一下，命令路径最好写绝对路径，不要写相对路径。因为定时任务是在系统后台执行的，所以相对路径是相对于系统的根目录，而不是相对于当前用户的目录。其次，要注意文件权限的设置，不同的用户有不同的权限，所以要根据实际情况来设置⌨</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/02/hello-world/"/>
      <url>/2025/09/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
