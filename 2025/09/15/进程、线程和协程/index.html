<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进程、线程和协程 | frostfishc</title><meta name="author" content="frostfish22"><meta name="copyright" content="frostfish22"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="进程、线程和协程：深入理解并发编程的基石在现代计算机系统和编程领域，进程、线程和协程是实现并发和并行计算的核心概念。它们既有密切的联系，又有本质的区别。 一、基本概念解析1.1 进程（Process）进程是程序在执行过程中的实例，是操作系统进行资源分配和调度的基本单位。它不仅包含了程序的代码和数据，还包括了程序执行所需的各种资源和状态信息。每个进程都拥有独立的内存空间、文件描述符和系统资源，这些资">
<meta property="og:type" content="article">
<meta property="og:title" content="进程、线程和协程">
<meta property="og:url" content="http://example.com/2025/09/15/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="frostfishc">
<meta property="og:description" content="进程、线程和协程：深入理解并发编程的基石在现代计算机系统和编程领域，进程、线程和协程是实现并发和并行计算的核心概念。它们既有密切的联系，又有本质的区别。 一、基本概念解析1.1 进程（Process）进程是程序在执行过程中的实例，是操作系统进行资源分配和调度的基本单位。它不仅包含了程序的代码和数据，还包括了程序执行所需的各种资源和状态信息。每个进程都拥有独立的内存空间、文件描述符和系统资源，这些资">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2025-09-15T02:08:52.000Z">
<meta property="article:modified_time" content="2025-09-15T02:25:44.326Z">
<meta property="article:author" content="frostfish22">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="协程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "进程、线程和协程",
  "url": "http://example.com/2025/09/15/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/",
  "image": "http://example.com/img/avatar.png",
  "datePublished": "2025-09-15T02:08:52.000Z",
  "dateModified": "2025-09-15T02:25:44.326Z",
  "author": [
    {
      "@type": "Person",
      "name": "frostfish22",
      "url": "https://frostfish22.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/15/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程、线程和协程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">frostfishc</span></a><a class="nav-page-title" href="/"><span class="site-name">进程、线程和协程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">进程、线程和协程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-15T02:08:52.000Z" title="发表于 2025-09-15 10:08:52">2025-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-15T02:25:44.326Z" title="更新于 2025-09-15 10:25:44">2025-09-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="进程、线程和协程：深入理解并发编程的基石"><a href="#进程、线程和协程：深入理解并发编程的基石" class="headerlink" title="进程、线程和协程：深入理解并发编程的基石"></a>进程、线程和协程：深入理解并发编程的基石</h2><p>在现代计算机系统和编程领域，进程、线程和协程是实现并发和并行计算的核心概念。它们既有密切的联系，又有本质的区别。</p>
<h2 id="一、基本概念解析"><a href="#一、基本概念解析" class="headerlink" title="一、基本概念解析"></a>一、基本概念解析</h2><h3 id="1-1-进程（Process）"><a href="#1-1-进程（Process）" class="headerlink" title="1.1 进程（Process）"></a>1.1 进程（Process）</h3><p>进程是程序在执行过程中的实例，是<strong>操作系统进行资源分配和调度的基本单位</strong>。它不仅包含了程序的代码和数据，还包括了程序执行所需的各种资源和状态信息。每个进程都拥有独立的内存空间、文件描述符和系统资源，这些资源在进程创建时被分配，并在进程终止时被回收。</p>
<blockquote>
<p>这里特别注意，进程才是操作系统进行资源分配和调度的基本单位，不是线程！！</p>
</blockquote>
<h4 id="1-1-1-进程的组成"><a href="#1-1-1-进程的组成" class="headerlink" title="1.1.1 进程的组成"></a>1.1.1 进程的组成</h4><p>一个完整的进程通常由以下几个部分组成：</p>
<ul>
<li><strong>程序（Program）</strong>：进程执行的代码，通常是存储在磁盘上的可执行文件</li>
<li><strong>数据（Data）</strong>：程序运行过程中使用和产生的数据</li>
<li><strong>进程控制块（Process Control Block, PCB）</strong>：操作系统用来管理和控制进程的核心数据结构</li>
<li><strong>内存空间</strong>：进程独占的虚拟地址空间，包括代码区、数据区、堆区和栈区等</li>
<li><strong>系统资源</strong>：如文件描述符、I&#x2F;O设备、信号处理器等</li>
</ul>
<h4 id="1-1-2-进程控制块（PCB）的结构"><a href="#1-1-2-进程控制块（PCB）的结构" class="headerlink" title="1.1.2 进程控制块（PCB）的结构"></a>1.1.2 进程控制块（PCB）的结构</h4><p>进程控制块（PCB）是操作系统中最重要的数据结构之一，它包含了进程的全部信息，是进程存在的唯一标志。每当创建一个新进程时，操作系统会为其分配一个PCB；当进程终止时，其PCB也会被释放。</p>
<p>典型的PCB包含以下信息：</p>
<ol>
<li><p><strong>进程标识符（Process ID, PID）</strong>：每个进程唯一的数字标识符，用于在系统中区分不同的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid;  <span class="comment">// 进程ID</span></span><br><span class="line"><span class="type">int</span> ppid; <span class="comment">// 父进程ID</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程状态（Process State）</strong>：描述进程当前所处的状态，如运行态、就绪态、阻塞态、挂起态等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> RUNNING, READY, BLOCKED, SUSPENDED &#125; state;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>程序计数器（Program Counter, PC）</strong>：记录进程下一条要执行的指令的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *program_counter;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>寄存器集合</strong>：保存进程执行过程中CPU寄存器的值，包括通用寄存器、栈指针、基址指针等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> general_registers[<span class="number">16</span>];</span><br><span class="line">    <span class="type">void</span> *stack_pointer;</span><br><span class="line">    <span class="type">void</span> *base_pointer;</span><br><span class="line">    <span class="comment">// 其他寄存器...</span></span><br><span class="line">&#125; registers;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内存管理信息</strong>：包括进程的内存映射表、页表等，用于管理进程的虚拟地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *page_table;  <span class="comment">// 页表指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> virtual_memory_size;  <span class="comment">// 虚拟内存大小</span></span><br><span class="line">    <span class="comment">// 其他内存管理信息...</span></span><br><span class="line">&#125; memory_info;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>资源使用情况</strong>：记录进程使用的CPU时间、内存大小、I&#x2F;O设备等资源信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cpu_time_used;  <span class="comment">// 已使用的CPU时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> memory_used;    <span class="comment">// 已使用的内存</span></span><br><span class="line">    <span class="comment">// 其他资源信息...</span></span><br><span class="line">&#125; resource_usage;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件描述符表</strong>：记录进程打开的文件和设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> file_descriptors[MAX_FILES];  <span class="comment">// 文件描述符数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程优先级</strong>：决定进程在CPU调度中的优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> priority;  <span class="comment">// 进程优先级</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程间通信信息</strong>：如信号、消息队列、管道等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> signals_pending;  <span class="comment">// 待处理的信号</span></span><br><span class="line">    <span class="comment">// 其他IPC信息...</span></span><br><span class="line">&#125; ipc_info;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>记账信息</strong>：用于系统计费和性能统计</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> start_time;  <span class="comment">// 进程开始时间</span></span><br><span class="line">    <span class="comment">// 其他记账信息...</span></span><br><span class="line">&#125; accounting_info;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-1-3-进程的生命周期"><a href="#1-1-3-进程的生命周期" class="headerlink" title="1.1.3 进程的生命周期"></a>1.1.3 进程的生命周期</h4><p>进程具有完整的生命周期，包括以下几个阶段：</p>
<ul>
<li><strong>创建（Creation）</strong>：通过系统调用（如<code>fork()</code>、<code>CreateProcess()</code>）创建新进程</li>
<li><strong>就绪（Ready）</strong>：进程已获得除CPU外的所有必要资源，等待CPU分配</li>
<li><strong>运行（Running）</strong>：进程正在占用CPU执行指令</li>
<li><strong>阻塞（Blocked&#x2F;Waiting）</strong>：进程等待某事件发生（如I&#x2F;O完成）而暂停执行</li>
<li><strong>终止（Termination）</strong>：进程执行完毕或出错，系统回收其资源</li>
<li><strong>挂起（Suspended）</strong>：进程被暂时换出内存，存放到外存中</li>
</ul>
<h4 id="1-1-4-进程的主要特点"><a href="#1-1-4-进程的主要特点" class="headerlink" title="1.1.4 进程的主要特点"></a>1.1.4 进程的主要特点</h4><ul>
<li><strong>独立性</strong>：每个进程都有自己独立的地址空间和资源，进程之间相互隔离，一个进程的崩溃不会直接影响其他进程</li>
<li><strong>并发性</strong>：多个进程可以同时运行，操作系统通过进程调度实现CPU的分时共享</li>
<li><strong>动态性</strong>：进程有创建、执行、暂停和终止等完整的生命周期，其状态会动态变化</li>
<li><strong>资源消耗大</strong>：进程切换和创建需要较多的系统资源和时间，因为涉及到完整的上下文切换（包括内存映射、寄存器状态等）</li>
<li><strong>保护机制</strong>：操作系统通过各种保护机制确保进程之间不会相互干扰，如内存保护、资源隔离等</li>
</ul>
<p><strong>示例：</strong><br>当你在电脑上打开一个浏览器、一个编辑器和一个音乐播放器时，每个应用程序都是一个独立的进程。操作系统会为每个进程分配独立的内存空间，它们之间不能直接访问彼此的内存。如果浏览器出现故障崩溃，编辑器和音乐播放器通常不会受到影响，仍然可以正常运行。</p>
<h3 id="1-2-线程（Thread）"><a href="#1-2-线程（Thread）" class="headerlink" title="1.2 线程（Thread）"></a>1.2 线程（Thread）</h3><p>线程是进程内的一个执行单元，是<strong>CPU调度的基本单位</strong>。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源（如代码段、数据段、堆、文件描述符等），但有各自独立的程序计数器、栈和寄存器集合。</p>
<h4 id="1-2-1-线程的组成"><a href="#1-2-1-线程的组成" class="headerlink" title="1.2.1 线程的组成"></a>1.2.1 线程的组成</h4><p>一个完整的线程通常由以下几个部分组成：</p>
<ul>
<li><strong>线程ID（Thread ID, TID）</strong>：线程的唯一标识符</li>
<li><strong>程序计数器（Program Counter）</strong>：记录线程下一条要执行的指令的地址</li>
<li><strong>寄存器集合</strong>：保存线程执行时的CPU寄存器状态</li>
<li><strong>线程栈（Thread Stack）</strong>：线程私有的栈空间，用于存储局部变量和函数调用信息</li>
<li><strong>线程局部存储（Thread Local Storage, TLS）</strong>：线程私有的数据存储区域</li>
<li><strong>线程状态</strong>：描述线程当前所处的状态（如运行、就绪、阻塞等）</li>
<li><strong>优先级</strong>：决定线程在CPU调度中的优先级</li>
</ul>
<h4 id="1-2-2-线程控制块（TCB）的结构"><a href="#1-2-2-线程控制块（TCB）的结构" class="headerlink" title="1.2.2 线程控制块（TCB）的结构"></a>1.2.2 线程控制块（TCB）的结构</h4><p>与进程类似，线程也有自己的控制块，称为线程控制块（Thread Control Block, TCB）。TCB是操作系统用于管理和控制线程的核心数据结构，包含了线程的全部信息。</p>
<p>典型的TCB包含以下信息：</p>
<ol>
<li><p><strong>线程标识符（Thread ID, TID）</strong>：每个线程唯一的数字标识符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> thread_id;  <span class="comment">// POSIX线程ID</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程状态</strong>：描述线程当前所处的状态，如运行态、就绪态、阻塞态等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> RUNNING, READY, BLOCKED &#125; state;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>程序计数器</strong>：记录线程下一条要执行的指令的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *program_counter;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>寄存器集合</strong>：保存线程执行过程中CPU寄存器的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> general_registers[<span class="number">16</span>];</span><br><span class="line">    <span class="type">void</span> *stack_pointer;</span><br><span class="line">    <span class="type">void</span> *base_pointer;</span><br><span class="line">    <span class="comment">// 其他寄存器...</span></span><br><span class="line">&#125; registers;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程栈指针</strong>：指向线程私有的栈空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *stack_start;</span><br><span class="line"><span class="type">void</span> *stack_end;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程优先级</strong>：决定线程在CPU调度中的优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> priority;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>所属进程的指针</strong>：指向线程所属的进程控制块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">process_ptr</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程局部存储信息</strong>：管理线程私有的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *thread_local_storage;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步原语信息</strong>：如锁、信号量等与线程同步相关的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> holding_locks[MAX_LOCKS];</span><br><span class="line">    <span class="comment">// 其他同步信息...</span></span><br><span class="line">&#125; sync_info;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-2-3-线程的实现模型"><a href="#1-2-3-线程的实现模型" class="headerlink" title="1.2.3 线程的实现模型"></a>1.2.3 线程的实现模型</h4><p>线程的实现主要有三种模型：</p>
<ol>
<li><p><strong>用户级线程（User-Level Threads, ULT）</strong></p>
<ul>
<li>由用户空间的线程库实现，操作系统内核看不到用户级线程</li>
<li>线程的创建、调度、销毁等操作都在用户空间完成，不需要内核干预</li>
<li>优点：线程切换开销小，不需要陷入内核；可以在不支持线程的操作系统上实现</li>
<li>缺点：一个线程阻塞会导致整个进程阻塞；不能利用多核CPU</li>
</ul>
</li>
<li><p><strong>内核级线程（Kernel-Level Threads, KLT）</strong></p>
<ul>
<li>由操作系统内核直接支持和管理</li>
<li>线程的创建、调度、销毁等操作都通过系统调用由内核完成</li>
<li>优点：一个线程阻塞不会影响其他线程；可以利用多核CPU</li>
<li>缺点：线程切换需要陷入内核，开销较大</li>
</ul>
</li>
<li><p><strong>混合级线程（Hybrid Threads）</strong></p>
<ul>
<li>结合了用户级线程和内核级线程的优点</li>
<li>用户级线程在应用程序中管理，内核级线程由操作系统管理</li>
<li>用户级线程与内核级线程之间通过”多对多”、”一对一”或”多对一”的方式映射</li>
<li>现代操作系统（如Linux、Windows）通常采用这种模型</li>
</ul>
</li>
</ol>
<h4 id="1-2-4-线程的状态转换"><a href="#1-2-4-线程的状态转换" class="headerlink" title="1.2.4 线程的状态转换"></a>1.2.4 线程的状态转换</h4><p>线程具有与进程类似的状态，但状态转换更加频繁：</p>
<ul>
<li><strong>新建（New）</strong>：线程被创建但尚未开始执行</li>
<li><strong>就绪（Ready）</strong>：线程已获得除CPU外的所有必要资源，等待CPU分配</li>
<li><strong>运行（Running）</strong>：线程正在占用CPU执行指令</li>
<li><strong>阻塞（Blocked&#x2F;Waiting）</strong>：线程等待某事件发生（如I&#x2F;O完成、锁释放等）而暂停执行</li>
<li><strong>终止（Terminated）</strong>：线程执行完毕或出错，资源被回收</li>
</ul>
<h4 id="1-2-5-线程的主要特点"><a href="#1-2-5-线程的主要特点" class="headerlink" title="1.2.5 线程的主要特点"></a>1.2.5 线程的主要特点</h4><ul>
<li><strong>轻量级</strong>：线程创建和切换的开销比进程小得多，因为线程共享进程的地址空间，无需切换页表和内存映射</li>
<li><strong>共享性</strong>：同一进程内的线程共享进程的内存空间和资源（如代码段、数据段、堆、文件描述符等）</li>
<li><strong>并发性</strong>：一个进程内的多个线程可以并发执行，提高程序的执行效率</li>
<li><strong>通信便捷</strong>：同一进程内的线程之间可以通过共享内存直接通信，比进程间通信更简单高效</li>
<li><strong>资源利用率高</strong>：多个线程可以充分利用CPU资源，特别是在多核处理器上</li>
<li><strong>独立性有限</strong>：同一进程内的线程共享内存空间，一个线程的错误可能会影响其他线程，甚至导致整个进程崩溃</li>
</ul>
<h4 id="1-2-6-线程与进程的比较"><a href="#1-2-6-线程与进程的比较" class="headerlink" title="1.2.6 线程与进程的比较"></a>1.2.6 线程与进程的比较</h4><table>
<thead>
<tr>
<th>特性</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>资源分配单位</td>
<td>是</td>
<td>否（共享进程资源）</td>
</tr>
<tr>
<td>CPU调度单位</td>
<td>否（线程是CPU调度的基本单位）</td>
<td>是</td>
</tr>
<tr>
<td>地址空间</td>
<td>独立</td>
<td>共享进程的地址空间</td>
</tr>
<tr>
<td>创建和切换开销</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>通信方式</td>
<td>进程间通信（IPC）</td>
<td>共享内存</td>
</tr>
<tr>
<td>安全性</td>
<td>高（相互隔离）</td>
<td>低（共享内存）</td>
</tr>
</tbody></table>
<p><strong>应用场景示例</strong><br>一个Web服务器进程通常会创建多个线程来处理同时到来的多个客户端请求。每个线程独立处理一个客户端的请求，但它们共享服务器进程的资源，如数据库连接池、缓存等。这样可以提高服务器的并发处理能力，同时避免创建多个进程带来的高开销。</p>
<h4 id="1-2-7-线程的实际应用"><a href="#1-2-7-线程的实际应用" class="headerlink" title="1.2.7 线程的实际应用"></a>1.2.7 线程的实际应用</h4><p>在实际编程中，我们可以通过各种编程语言提供的线程库来创建和管理线程。以下是一些常见编程语言中创建线程的示例：</p>
<p><strong>C++（使用std::thread）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread function executing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main function executing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主线程继续执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is running&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python（使用threading模块）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_function</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;name&#125;</span>: starting&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;name&#125;</span>: finishing&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建线程</span></span><br><span class="line">    thread = threading.Thread(target=thread_function, args=(<span class="string">&quot;A&quot;</span>,))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 主线程继续执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main: starting&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main: finishing&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待线程执行完毕</span></span><br><span class="line">    thread.join()</span><br></pre></td></tr></table></figure>

<h3 id="1-3-协程（Coroutine）"><a href="#1-3-协程（Coroutine）" class="headerlink" title="1.3 协程（Coroutine）"></a>1.3 协程（Coroutine）</h3><p>协程是一种用户态的轻量级线程，也被称为微线程（Microthread）或纤程（Fiber）。协程的调度<strong>完全由用户程序控制，而非操作系统内核</strong>，实现了在<strong>单个线程内的多任务协作式调度</strong>。</p>
<h4 id="1-3-1-协程的组成"><a href="#1-3-1-协程的组成" class="headerlink" title="1.3.1 协程的组成"></a>1.3.1 协程的组成</h4><p>协程主要由以下几个部分组成：</p>
<ul>
<li><strong>程序代码</strong>：协程执行的具体逻辑</li>
<li><strong>局部变量</strong>：协程运行过程中使用的变量</li>
<li><strong>程序计数器</strong>：记录协程当前执行位置的指针</li>
<li><strong>栈帧</strong>：存储协程的执行上下文和返回地址</li>
<li><strong>状态信息</strong>：标记协程当前的运行状态</li>
<li><strong>调度器</strong>：负责协程间的切换和管理（通常由用户级库实现）</li>
</ul>
<h4 id="1-3-2-协程的实现机制"><a href="#1-3-2-协程的实现机制" class="headerlink" title="1.3.2 协程的实现机制"></a>1.3.2 协程的实现机制</h4><p>在不同的编程语言中，协程有多种实现方式：</p>
<ol>
<li><p><strong>基于生成器（Generator-based）</strong><br>通过生成器函数实现简单的协程功能，如Python早期版本的<code>yield</code>机制</p>
</li>
<li><p><strong>基于状态机（State Machine-based）</strong><br>使用状态变量显式管理协程的执行状态</p>
</li>
<li><p><strong>基于栈（Stack-based）</strong><br>为每个协程分配独立的栈空间，支持更复杂的函数调用层次</p>
</li>
<li><p><strong>基于编译器转换（Compiler Transformation-based）</strong><br>通过编译器将协程代码转换为状态机形式，如C++20的协程实现</p>
</li>
</ol>
<h4 id="1-3-3-协程的状态转换"><a href="#1-3-3-协程的状态转换" class="headerlink" title="1.3.3 协程的状态转换"></a>1.3.3 协程的状态转换</h4><p>协程通常具有以下几种状态：</p>
<ul>
<li><strong>创建（Created）</strong>：协程对象已创建但尚未开始执行</li>
<li><strong>就绪（Ready）</strong>：协程可以开始执行，但当前未被调度</li>
<li><strong>运行（Running）</strong>：协程正在执行</li>
<li><strong>挂起（Suspended）</strong>：协程暂时停止执行，等待唤醒</li>
<li><strong>完成（Completed）</strong>：协程执行完毕</li>
<li><strong>异常（Exceptional）</strong>：协程执行过程中发生异常</li>
</ul>
<p>协程的状态转换完全由用户程序控制，通过显式的挂起（yield）和恢复（resume）操作实现。</p>
<h4 id="1-3-4-协程的主要特点"><a href="#1-3-4-协程的主要特点" class="headerlink" title="1.3.4 协程的主要特点"></a>1.3.4 协程的主要特点</h4><ul>
<li><p><strong>用户态调度</strong>：协程的创建、切换和销毁完全由用户程序控制，不需要内核干预，避免了内核态和用户态切换的开销</p>
</li>
<li><p><strong>极高的执行效率</strong>：协程切换的开销非常小，仅涉及上下文保存和恢复，接近普通函数调用的开销</p>
</li>
<li><p><strong>非抢占式调度</strong>：协程不会被强制中断，只有在显式调用yield等函数时才会主动让出执行权，避免了线程安全问题</p>
</li>
<li><p><strong>共享内存</strong>：同一线程内的协程共享该线程的内存空间，通信效率高，但需要注意数据访问的同步问题</p>
</li>
<li><p><strong>高并发潜力</strong>：单线程内可以创建成千上万个协程，适合处理大量I&#x2F;O密集型任务</p>
</li>
</ul>
<h4 id="1-3-5-协程与线程的区别"><a href="#1-3-5-协程与线程的区别" class="headerlink" title="1.3.5 协程与线程的区别"></a>1.3.5 协程与线程的区别</h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>协程</strong></th>
<th><strong>线程</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调度方式</strong></td>
<td>用户态非抢占式</td>
<td>内核态抢占式</td>
</tr>
<tr>
<td><strong>切换开销</strong></td>
<td>极小（~几十纳秒）</td>
<td>较大（~几微秒到几毫秒）</td>
</tr>
<tr>
<td><strong>创建数量</strong></td>
<td>可创建成千上万个</td>
<td>通常最多创建数千个</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较小（几KB到几十KB）</td>
<td>较大（几MB）</td>
</tr>
<tr>
<td><strong>并发模型</strong></td>
<td>协作式多任务</td>
<td>抢占式多任务</td>
</tr>
<tr>
<td><strong>阻塞影响</strong></td>
<td>阻塞会导致整个线程阻塞</td>
<td>单个线程阻塞不影响其他线程</td>
</tr>
</tbody></table>
<h4 id="1-3-6-多语言协程实现示例"><a href="#1-3-6-多语言协程实现示例" class="headerlink" title="1.3.6 多语言协程实现示例"></a>1.3.6 多语言协程实现示例</h4><p><strong>Python（使用async&#x2F;await）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)  <span class="comment"># 协程挂起，等待指定时间</span></span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 并发执行两个协程</span></span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;World&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;started at&quot;</span>, asyncio.current_time())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待两个任务完成</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finished at&quot;</span>, asyncio.current_time())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行主协程</span></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript（使用async&#x2F;await）：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url); <span class="comment">// 协程挂起，等待网络请求完成</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 并发执行多个异步操作</span></span><br><span class="line">        <span class="keyword">const</span> [userData, productData] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">            <span class="title function_">fetchData</span>(<span class="string">&#x27;/api/users&#x27;</span>),</span><br><span class="line">            <span class="title function_">fetchData</span>(<span class="string">&#x27;/api/products&#x27;</span>)</span><br><span class="line">        ]);</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户数据:&#x27;</span>, userData);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;产品数据:&#x27;</span>, productData);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求失败:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<p><strong>C++20（使用协程支持库）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的协程返回类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟异步操作的协程函数</span></span><br><span class="line"><span class="function">Task <span class="title">asyncOperation</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> delay)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Operation &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;; <span class="comment">// 挂起协程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Operation &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; resumed after delay\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> task1 = <span class="built_in">asyncOperation</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> task2 = <span class="built_in">asyncOperation</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="comment">// 在实际应用中，需要一个调度器来管理协程的恢复</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Go（使用goroutine和channel）：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go语言中的goroutine是一种特殊的协程实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;processing job&quot;</span>, j)</span><br><span class="line">        time.Sleep(time.Second) <span class="comment">// 模拟工作</span></span><br><span class="line">        results &lt;- j * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动3个worker协程</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送9个任务</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集所有结果</span></span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++ &#123;</span><br><span class="line">        &lt;-results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、进程、线程和协程的关联"><a href="#二、进程、线程和协程的关联" class="headerlink" title="二、进程、线程和协程的关联"></a>二、进程、线程和协程的关联</h2><p>进程、线程和协程之间存在着密切的关联，它们共同构成了现代操作系统和编程语言中并发编程的基础。</p>
<h3 id="2-1-层次结构关系"><a href="#2-1-层次结构关系" class="headerlink" title="2.1 层次结构关系"></a>2.1 层次结构关系</h3><ul>
<li><strong>进程包含线程</strong>：一个进程可以包含多个线程，线程是进程内的执行单元</li>
<li><strong>线程包含协程</strong>：一个线程可以运行多个协程，协程是线程内的更轻量级的执行单元</li>
<li><strong>资源共享关系</strong>：进程间资源独立，同一进程内的线程共享进程资源，同一线程内的协程共享线程资源</li>
</ul>
<h3 id="2-2-调度关系"><a href="#2-2-调度关系" class="headerlink" title="2.2 调度关系"></a>2.2 调度关系</h3><ul>
<li><strong>操作系统调度进程和线程</strong>：进程和线程的调度由操作系统内核负责，属于抢占式调度</li>
<li><strong>用户程序调度协程</strong>：协程的调度由用户程序控制，属于非抢占式调度</li>
<li><strong>多级调度</strong>：现代系统中，通常是操作系统调度进程和线程，而在用户程序内部再调度协程</li>
</ul>
<h3 id="2-3-协作关系"><a href="#2-3-协作关系" class="headerlink" title="2.3 协作关系"></a>2.3 协作关系</h3><ul>
<li><strong>进程间协作</strong>：通过进程间通信（IPC）机制，如管道、消息队列、共享内存等</li>
<li><strong>线程间协作</strong>：通过锁、信号量、条件变量等同步原语</li>
<li><strong>协程间协作</strong>：通过yield、await等机制主动让出执行权</li>
</ul>
<h2 id="三、进程、线程和协程的区别"><a href="#三、进程、线程和协程的区别" class="headerlink" title="三、进程、线程和协程的区别"></a>三、进程、线程和协程的区别</h2><p>虽然进程、线程和协程都是实现并发的机制，但它们在多个方面存在着本质的区别。</p>
<h3 id="3-1-调度层面的区别"><a href="#3-1-调度层面的区别" class="headerlink" title="3.1 调度层面的区别"></a>3.1 调度层面的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>调度者</td>
<td>操作系统内核</td>
<td>操作系统内核</td>
<td>用户程序</td>
</tr>
<tr>
<td>调度方式</td>
<td>抢占式</td>
<td>抢占式</td>
<td>非抢占式</td>
</tr>
<tr>
<td>切换开销</td>
<td>大（涉及上下文切换、内存映射等）</td>
<td>中（共享内存空间，只需切换寄存器和栈）</td>
<td>小（基本是函数调用级别）</td>
</tr>
<tr>
<td>切换时机</td>
<td>由操作系统决定，可能在任意时刻发生</td>
<td>由操作系统决定，可能在任意时刻发生</td>
<td>由用户程序显式控制，只有在特定点切换</td>
</tr>
</tbody></table>
<h3 id="3-2-资源层面的区别"><a href="#3-2-资源层面的区别" class="headerlink" title="3.2 资源层面的区别"></a>3.2 资源层面的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>内存空间</td>
<td>独立的地址空间</td>
<td>共享进程的地址空间</td>
<td>共享线程的内存空间</td>
</tr>
<tr>
<td>系统资源</td>
<td>独立的文件描述符、信号处理等</td>
<td>共享进程的系统资源</td>
<td>共享线程的资源</td>
</tr>
<tr>
<td>创建开销</td>
<td>大</td>
<td>中</td>
<td>小</td>
</tr>
<tr>
<td>数量限制</td>
<td>较少（受系统资源限制）</td>
<td>较多（比进程多，但仍有限制）</td>
<td>极多（理论上可以创建上百万个）</td>
</tr>
</tbody></table>
<h3 id="3-3-通信机制的区别"><a href="#3-3-通信机制的区别" class="headerlink" title="3.3 通信机制的区别"></a>3.3 通信机制的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>通信方式</td>
<td>IPC机制（管道、消息队列、共享内存等）</td>
<td>共享变量（需要同步机制）</td>
<td>直接共享变量（通常不需要同步机制）</td>
</tr>
<tr>
<td>通信效率</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>同步复杂度</td>
<td>较高</td>
<td>中</td>
<td>低（通常不需要显式同步）</td>
</tr>
</tbody></table>
<h3 id="3-4-适用场景的区别"><a href="#3-4-适用场景的区别" class="headerlink" title="3.4 适用场景的区别"></a>3.4 适用场景的区别</h3><table>
<thead>
<tr>
<th>场景</th>
<th>最适合的机制</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>CPU密集型任务</td>
<td>多线程或多进程</td>
<td>需要充分利用多核CPU</td>
</tr>
<tr>
<td>I&#x2F;O密集型任务（如网络请求、文件操作）</td>
<td>协程或多线程</td>
<td>协程在大量I&#x2F;O操作时效率更高，资源消耗更少</td>
</tr>
<tr>
<td>独立性要求高的任务</td>
<td>多进程</td>
<td>进程间相互隔离，一个进程崩溃不会影响其他进程</td>
</tr>
<tr>
<td>内存消耗敏感的场景</td>
<td>协程</td>
<td>协程占用内存极小，可以创建大量协程</td>
</tr>
<tr>
<td>实时性要求高的场景</td>
<td>多线程或协程</td>
<td>线程切换比进程快，协程切换更快</td>
</tr>
</tbody></table>
<h2 id="四、深入理解：从实例看三者的运作机制"><a href="#四、深入理解：从实例看三者的运作机制" class="headerlink" title="四、深入理解：从实例看三者的运作机制"></a>四、深入理解：从实例看三者的运作机制</h2><p>为了更好地理解进程、线程和协程的区别，我们通过一个简单的类比来形象地说明它们的运作方式。</p>
<h3 id="4-1-类比：工厂、车间和工人"><a href="#4-1-类比：工厂、车间和工人" class="headerlink" title="4.1 类比：工厂、车间和工人"></a>4.1 类比：工厂、车间和工人</h3><ul>
<li><strong>进程</strong>：就像一个独立的工厂，有自己的厂房、设备和资源</li>
<li><strong>线程</strong>：就像工厂里的车间，可以同时生产不同的产品，但共享工厂的资源</li>
<li><strong>协程</strong>：就像车间里的工人，在同一个车间内工作，可以协作完成任务，但一次只能有一个工人在工作</li>
</ul>
<h3 id="4-2-实际代码示例"><a href="#4-2-实际代码示例" class="headerlink" title="4.2 实际代码示例"></a>4.2 实际代码示例</h3><h4 id="4-2-1-多进程示例（Python）"><a href="#4-2-1-多进程示例（Python）" class="headerlink" title="4.2.1 多进程示例（Python）"></a>4.2.1 多进程示例（Python）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Process <span class="subst">&#123;name&#125;</span> is running&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Process <span class="subst">&#123;name&#125;</span> is done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(<span class="string">f&#x27;P<span class="subst">&#123;i&#125;</span>&#x27;</span>,))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-多线程示例（Python）"><a href="#4-2-2-多线程示例（Python）" class="headerlink" title="4.2.2 多线程示例（Python）"></a>4.2.2 多线程示例（Python）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Thread <span class="subst">&#123;name&#125;</span> is running&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Thread <span class="subst">&#123;name&#125;</span> is done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=task, args=(<span class="string">f&#x27;T<span class="subst">&#123;i&#125;</span>&#x27;</span>,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-协程示例（Python）"><a href="#4-2-3-协程示例（Python）" class="headerlink" title="4.2.3 协程示例（Python）"></a>4.2.3 协程示例（Python）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Coroutine <span class="subst">&#123;name&#125;</span> is running&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟I/O操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Coroutine <span class="subst">&#123;name&#125;</span> is done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建协程任务</span></span><br><span class="line">    tasks = [task(<span class="string">f&#x27;C<span class="subst">&#123;i&#125;</span>&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">    <span class="comment"># 并发执行协程</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<h2 id="五、总结：如何选择合适的并发模型"><a href="#五、总结：如何选择合适的并发模型" class="headerlink" title="五、总结：如何选择合适的并发模型"></a>五、总结：如何选择合适的并发模型</h2><p>在实际开发中，选择进程、线程还是协程来实现并发，取决于多种因素。以下是一些指导原则：</p>
<h3 id="5-1-考虑任务类型"><a href="#5-1-考虑任务类型" class="headerlink" title="5.1 考虑任务类型"></a>5.1 考虑任务类型</h3><ul>
<li><strong>CPU密集型任务</strong>：如果你的任务主要是进行计算，需要充分利用多核CPU，那么多进程或多线程可能是更好的选择。在Python中，由于GIL（全局解释器锁）的存在，多线程在CPU密集型任务上可能无法充分利用多核，此时多进程可能更合适。</li>
<li><strong>I&#x2F;O密集型任务</strong>：如果你的任务主要是等待I&#x2F;O操作（如网络请求、文件读写等），那么协程可能是最高效的选择，因为协程可以在I&#x2F;O等待时切换到其他任务，充分利用CPU时间。</li>
</ul>
<h3 id="5-2-考虑资源限制"><a href="#5-2-考虑资源限制" class="headerlink" title="5.2 考虑资源限制"></a>5.2 考虑资源限制</h3><ul>
<li><strong>内存限制</strong>：如果你的应用需要创建大量的并发执行单元，协程是最佳选择，因为每个协程占用的内存非常小。</li>
<li><strong>系统资源</strong>：进程创建和切换的开销较大，因此在系统资源有限的情况下，应谨慎使用多进程。</li>
</ul>
<h3 id="5-3-考虑程序复杂度"><a href="#5-3-考虑程序复杂度" class="headerlink" title="5.3 考虑程序复杂度"></a>5.3 考虑程序复杂度</h3><ul>
<li><strong>并发控制复杂度</strong>：多线程和多进程需要处理复杂的同步和互斥问题，容易出现死锁等问题。而协程由于是非抢占式调度，通常不需要复杂的同步机制。</li>
<li><strong>调试难度</strong>：多线程和多进程程序的调试通常比协程程序更困难，因为线程和进程的切换由操作系统控制，执行流更难预测。</li>
</ul>
<h3 id="5-4-混合使用的趋势"><a href="#5-4-混合使用的趋势" class="headerlink" title="5.4 混合使用的趋势"></a>5.4 混合使用的趋势</h3><p>在实际项目中，常常会混合使用进程、线程和协程，以充分发挥它们各自的优势。例如：</p>
<ul>
<li>使用多进程来利用多核CPU</li>
<li>在每个进程中使用多线程来处理不同类型的任务</li>
<li>在线程中使用协程来高效处理大量I&#x2F;O操作</li>
</ul>
<h2 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h2><p>进程、线程和协程是现代计算机系统和编程中实现并发的三种重要机制。它们各有优缺点，适用于不同的场景。理解它们的概念、关联和区别，对于设计高效、可靠的并发程序至关重要。</p>
<p>随着硬件的发展和编程语言的演进，我们有了越来越多的并发编程工具和模型。选择合适的并发模型不仅需要考虑技术因素，还需要考虑应用场景、性能要求和开发维护成本等多个方面。</p>
<p>希望本文能够帮助你更深入地理解进程、线程和协程，在实际开发中做出更明智的选择。如果你有任何疑问或想法，欢迎在评论区讨论分享！</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/16/Python3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Python3 数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python3 数据结构</div></div><div class="info-2"><div class="info-item-1">Python3 数据结构详解：从基础到进阶数据结构是程序的骨架，掌握Python中的数据结构对于编写高效、清晰的代码至关重要。本文将详细介绍Python中最常用的四大数据结构：列表（数组）、元组、集合和字典，包括它们的基本概念、常用操作、进阶技巧以及使用场景。 一、列表（List）：Python的动态数组1.1 基本概念与特点列表是Python中最常用的数据结构之一，相当于其他编程语言中的动态数组。它具有以下特点：  有序的元素集合 可以存储任意类型的元素（混合类型也支持） 可变（元素可以被修改、添加和删除） 使用方括号 [] 表示  1.2 创建与基本操作12345678910111213141516171819# 创建列表的多种方式empty_list = []numbers = [1, 2, 3, 4, 5]mixed_list = [1, &quot;hello&quot;, 3.14, True]list_from_range = list(range(10))list_from_string = list(&quot;python&quot;)# 访问元素（通过索引）...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Dockerfile%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="Dockerfile基本介绍与使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Dockerfile基本介绍与使用</div></div><div class="info-2"><div class="info-item-1">Dockerfile在现代软件开发和部署中，容器化技术已经成为一种标准实践。Docker作为最流行的容器化平台，其核心功能之一就是通过Dockerfile来定义和构建容器镜像。本文将详细介绍Dockerfile的基本概念、编写规则、运行方法以及如何将构建的镜像上传到仓库。 Dockerfile的基本介绍什么是DockerfileDockerfile是一个包含用于自动构建Docker镜像的脚本命令的文本文件。它由一系列指令和参数组成，这些指令告诉Docker如何构建一个特定的镜像。使用Dockerfile，开发者可以将应用程序及其依赖环境的构建过程自动化、标准化和可复制化。 Dockerfile的作用和优势 自动化构建：通过Dockerfile，开发者可以自动化构建镜像的过程，无需手动执行每一步操作 版本控制：Dockerfile可以像代码一样进行版本控制，便于追踪和管理镜像的变更 一致性：确保在不同环境中构建的镜像完全一致，避免”在我的机器上可以运行”的问题 可扩展性：通过Dockerfile的层叠特性，可以基于已有镜像快速构建新的镜像 文档化：Dockerfile本身就是构建过...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">frostfish22</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/frostfish22"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">1.</span> <span class="toc-text">进程、线程和协程：深入理解并发编程的基石</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">一、基本概念解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 进程（Process）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1.1 进程的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%89%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.1.2 进程控制块（PCB）的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.1.3 进程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.1.4 进程的主要特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 线程（Thread）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.2.1 线程的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88TCB%EF%BC%89%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.2.2 线程控制块（TCB）的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">1.2.3 线程的实现模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.4.</span> <span class="toc-text">1.2.4 线程的状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.5.</span> <span class="toc-text">1.2.5 线程的主要特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.6.</span> <span class="toc-text">1.2.6 线程与进程的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">2.2.7.</span> <span class="toc-text">1.2.7 线程的实际应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8D%8F%E7%A8%8B%EF%BC%88Coroutine%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 协程（Coroutine）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.3.1 协程的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.3.2 协程的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.3.3 协程的状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.4.</span> <span class="toc-text">1.3.4 协程的主要特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.5.</span> <span class="toc-text">1.3.5 协程与线程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.6.</span> <span class="toc-text">1.3.6 多语言协程实现示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">3.</span> <span class="toc-text">二、进程、线程和协程的关联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 层次结构关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%B0%83%E5%BA%A6%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 调度关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 协作关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">三、进程、线程和协程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%B0%83%E5%BA%A6%E5%B1%82%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 调度层面的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%B5%84%E6%BA%90%E5%B1%82%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 资源层面的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 通信机制的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 适用场景的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%AE%9E%E4%BE%8B%E7%9C%8B%E4%B8%89%E8%80%85%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">四、深入理解：从实例看三者的运作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%B1%BB%E6%AF%94%EF%BC%9A%E5%B7%A5%E5%8E%82%E3%80%81%E8%BD%A6%E9%97%B4%E5%92%8C%E5%B7%A5%E4%BA%BA"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 类比：工厂、车间和工人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 实际代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%A4%BA%E4%BE%8B%EF%BC%88Python%EF%BC%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">4.2.1 多进程示例（Python）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B%EF%BC%88Python%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">4.2.2 多线程示例（Python）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%8D%8F%E7%A8%8B%E7%A4%BA%E4%BE%8B%EF%BC%88Python%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">4.2.3 协程示例（Python）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">五、总结：如何选择合适的并发模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%80%83%E8%99%91%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 考虑任务类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%80%83%E8%99%91%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 考虑资源限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%80%83%E8%99%91%E7%A8%8B%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 考虑程序复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B6%8B%E5%8A%BF"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 混合使用的趋势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BB%93%E8%AF%AD"><span class="toc-number">7.</span> <span class="toc-text">六、结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/16/Python3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Python3 数据结构">Python3 数据结构</a><time datetime="2025-09-16T05:35:33.000Z" title="发表于 2025-09-16 13:35:33">2025-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/15/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/" title="进程、线程和协程">进程、线程和协程</a><time datetime="2025-09-15T02:08:52.000Z" title="发表于 2025-09-15 10:08:52">2025-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Dockerfile%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="Dockerfile基本介绍与使用">Dockerfile基本介绍与使用</a><time datetime="2025-09-11T00:54:42.000Z" title="发表于 2025-09-11 08:54:42">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/10/C-%E6%8C%87%E9%92%88/" title="C++指针">C++指针</a><time datetime="2025-09-10T00:59:29.000Z" title="发表于 2025-09-10 08:59:29">2025-09-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/Linux%E8%AE%BE%E7%BD%AESystemctl%E6%9C%8D%E5%8A%A1/" title="Linux设置Systemctl服务">Linux设置Systemctl服务</a><time datetime="2025-09-02T07:23:21.000Z" title="发表于 2025-09-02 15:23:21">2025-09-02</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By frostfish22</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>